{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Aralez (\u0531\u0580\u0561\u056c\u0565\u0566), Reverse proxy built on top of Cloudflare's Pingora Aralez is a high-performance Rust reverse proxy with zero-configuration automatic HTTP, HTTPS, gRPC, WebSockets protocol handling, TLS, and upstream management, featuring Consul and Kubernetes integration for dynamic pod discovery and health-checked routing, acting as a lightweight ingress-style proxy. What Aralez means ? Aralez = \u0531\u0580\u0561\u056c\u0565\u0566 .Named after the legendary Armenian guardian spirit, winged dog-like creature, that descend upon fallen heroes to lick their wounds and resurrect them. . Built on Rust, on top of Cloudflare\u2019s Pingora engine , Aralez delivers world-class performance, security and scalability \u2014 right out of the box. Support my OpenSource initiative : \ud83d\udd27 Key Features Dynamic Config Reloads \u2014 Upstreams can be updated live via API, no restart required. TLS Termination \u2014 Built-in OpenSSL support. Automatic load of certificates \u2014 Automatically reads and loads certificates from a folder, without a restart. Upstreams TLS detection \u2014 Aralez will automatically detect if upstreams uses secure connection. Built in rate limiter \u2014 Limit requests to server, by setting up upper limit for requests per seconds, per virtualhost. Global rate limiter \u2014 Set rate limit for all virtualhosts. Per path rate limiter \u2014 Set rate limit for specific paths. Path limits will override global limits. Authentication \u2014 Supports Basic Auth, API tokens, and JWT verification. Basic Auth API Key via x-api-key header JWT Auth , with tokens issued by Aralez itself via /jwt API \u2b07\ufe0f See below for examples and implementation details. Load Balancing Strategies Round-robin Failover with health checks Sticky sessions via cookies Unified Port \u2014 Serve HTTP and WebSocket traffic over the same connection. Built in file server \u2014 Build in minimalistic file server for serving static files, should be added as upstreams for public access. Memory Safe \u2014 Created purely on Rust. High Performance \u2014 Built with Pingora and tokio for async I/O. \ud83c\udf0d Highlights \u2699\ufe0f Upstream Providers: file Upstreams are declared in config file. consul Upstreams are dynamically updated from Hashicorp Consul. \ud83d\udd01 Hot Reloading: Modify upstreams on the fly via upstreams.yaml \u2014 no restart needed. \ud83d\udd2e Automatic WebSocket Support: Zero config \u2014 connection upgrades are handled seamlessly. \ud83d\udd2e Automatic GRPC Support: Zero config, Requires ssl to proxy, gRPC handled seamlessly. \ud83d\udd2e Upstreams Session Stickiness: Enable/Disable Sticky sessions globally. \ud83d\udd10 TLS Termination: Fully supports TLS for upstreams and downstreams. \ud83d\udee1\ufe0f Built-in Authentication Basic Auth, JWT, API key. \ud83e\udde0 Header Injection: Global and per-route header configuration. \ud83e\uddea Health Checks: Pluggable health check methods for upstreams. \ud83d\udef0\ufe0f Remote Config Push: Lightweight HTTP API to update configs from CI/CD or other systems. \ud83d\udcc1 File Structure . \u251c\u2500\u2500 main . yaml # Main configuration loaded at startup \u251c\u2500\u2500 upstreams . yaml # Watched config with upstream mappings \u251c\u2500\u2500 etc / \u2502 \u251c\u2500\u2500 server . crt # TLS certificate (required if using TLS) \u2502 \u2514\u2500\u2500 key . pem # TLS private key \ud83d\udee0 Configuration Overview \ud83d\udd27 main.yaml Contains basic startup parameters, loaded on startup. \ud83c\udf10 upstreams.yaml provider : file or consul File-based upstreams define: Hostnames and routing paths Backend servers (load-balanced) Optional request headers, specific to this upstream Global headers (e.g., CORS) apply to all proxied responses Optional authentication (Basic, API Key, JWT) \ud83d\udd04 Hot Reload Changes to upstreams.yaml are applied immediately. No need to restart the proxy \u2014 just save the file. If consul provider is chosen, upstreams will be periodically update from Consul's API. \ud83d\udd10 TLS Support To enable TLS for A proxy server: Currently only OpenSSL is supported, working on Boringssl and Rustls Set proxy_address_tls in main.yaml Provide tls_certificate and tls_key_file \ud83d\udce1 Remote Config API Push new upstreams.yaml over HTTP to config_address ( :3000 by default). Useful for CI/CD automation or remote config updates. URL parameter. key=MASTERKEY is required. MASTERKEY is the value of master_key in the main.yaml curl -XPOST --data-binary @./etc/upstreams.txt 127 .0.0.1:3000/conf?key = ${ MASTERKEY } \ud83d\udcc3 License Apache License Version 2.0 \ud83e\udde0 Notes Uses Pingora under the hood for efficiency and flexibility. Designed for edge proxying, internal routing, or hybrid cloud scenarios. Transparent, fully automatic WebSocket upgrade support. Transparent, fully automatic gRPC proxy. Sticky session support. HTTP2 ready.","title":"Home"},{"location":"#aralez-reverse-proxy-built-on-top-of-cloudflares-pingora","text":"Aralez is a high-performance Rust reverse proxy with zero-configuration automatic HTTP, HTTPS, gRPC, WebSockets protocol handling, TLS, and upstream management, featuring Consul and Kubernetes integration for dynamic pod discovery and health-checked routing, acting as a lightweight ingress-style proxy. What Aralez means ? Aralez = \u0531\u0580\u0561\u056c\u0565\u0566 .Named after the legendary Armenian guardian spirit, winged dog-like creature, that descend upon fallen heroes to lick their wounds and resurrect them. . Built on Rust, on top of Cloudflare\u2019s Pingora engine , Aralez delivers world-class performance, security and scalability \u2014 right out of the box. Support my OpenSource initiative :","title":"Aralez (\u0531\u0580\u0561\u056c\u0565\u0566), Reverse proxy built on top of Cloudflare's Pingora"},{"location":"#key-features","text":"Dynamic Config Reloads \u2014 Upstreams can be updated live via API, no restart required. TLS Termination \u2014 Built-in OpenSSL support. Automatic load of certificates \u2014 Automatically reads and loads certificates from a folder, without a restart. Upstreams TLS detection \u2014 Aralez will automatically detect if upstreams uses secure connection. Built in rate limiter \u2014 Limit requests to server, by setting up upper limit for requests per seconds, per virtualhost. Global rate limiter \u2014 Set rate limit for all virtualhosts. Per path rate limiter \u2014 Set rate limit for specific paths. Path limits will override global limits. Authentication \u2014 Supports Basic Auth, API tokens, and JWT verification. Basic Auth API Key via x-api-key header JWT Auth , with tokens issued by Aralez itself via /jwt API \u2b07\ufe0f See below for examples and implementation details. Load Balancing Strategies Round-robin Failover with health checks Sticky sessions via cookies Unified Port \u2014 Serve HTTP and WebSocket traffic over the same connection. Built in file server \u2014 Build in minimalistic file server for serving static files, should be added as upstreams for public access. Memory Safe \u2014 Created purely on Rust. High Performance \u2014 Built with Pingora and tokio for async I/O.","title":"\ud83d\udd27 Key Features"},{"location":"#highlights","text":"\u2699\ufe0f Upstream Providers: file Upstreams are declared in config file. consul Upstreams are dynamically updated from Hashicorp Consul. \ud83d\udd01 Hot Reloading: Modify upstreams on the fly via upstreams.yaml \u2014 no restart needed. \ud83d\udd2e Automatic WebSocket Support: Zero config \u2014 connection upgrades are handled seamlessly. \ud83d\udd2e Automatic GRPC Support: Zero config, Requires ssl to proxy, gRPC handled seamlessly. \ud83d\udd2e Upstreams Session Stickiness: Enable/Disable Sticky sessions globally. \ud83d\udd10 TLS Termination: Fully supports TLS for upstreams and downstreams. \ud83d\udee1\ufe0f Built-in Authentication Basic Auth, JWT, API key. \ud83e\udde0 Header Injection: Global and per-route header configuration. \ud83e\uddea Health Checks: Pluggable health check methods for upstreams. \ud83d\udef0\ufe0f Remote Config Push: Lightweight HTTP API to update configs from CI/CD or other systems.","title":"\ud83c\udf0d Highlights"},{"location":"#file-structure","text":". \u251c\u2500\u2500 main . yaml # Main configuration loaded at startup \u251c\u2500\u2500 upstreams . yaml # Watched config with upstream mappings \u251c\u2500\u2500 etc / \u2502 \u251c\u2500\u2500 server . crt # TLS certificate (required if using TLS) \u2502 \u2514\u2500\u2500 key . pem # TLS private key","title":"\ud83d\udcc1 File Structure"},{"location":"#configuration-overview","text":"","title":"\ud83d\udee0 Configuration Overview"},{"location":"#mainyaml","text":"Contains basic startup parameters, loaded on startup.","title":"\ud83d\udd27 main.yaml"},{"location":"#upstreamsyaml","text":"provider : file or consul File-based upstreams define: Hostnames and routing paths Backend servers (load-balanced) Optional request headers, specific to this upstream Global headers (e.g., CORS) apply to all proxied responses Optional authentication (Basic, API Key, JWT)","title":"\ud83c\udf10 upstreams.yaml"},{"location":"#hot-reload","text":"Changes to upstreams.yaml are applied immediately. No need to restart the proxy \u2014 just save the file. If consul provider is chosen, upstreams will be periodically update from Consul's API.","title":"\ud83d\udd04 Hot Reload"},{"location":"#tls-support","text":"To enable TLS for A proxy server: Currently only OpenSSL is supported, working on Boringssl and Rustls Set proxy_address_tls in main.yaml Provide tls_certificate and tls_key_file","title":"\ud83d\udd10 TLS Support"},{"location":"#remote-config-api","text":"Push new upstreams.yaml over HTTP to config_address ( :3000 by default). Useful for CI/CD automation or remote config updates. URL parameter. key=MASTERKEY is required. MASTERKEY is the value of master_key in the main.yaml curl -XPOST --data-binary @./etc/upstreams.txt 127 .0.0.1:3000/conf?key = ${ MASTERKEY }","title":"\ud83d\udce1 Remote Config API"},{"location":"#license","text":"Apache License Version 2.0","title":"\ud83d\udcc3 License"},{"location":"#notes","text":"Uses Pingora under the hood for efficiency and flexibility. Designed for edge proxying, internal routing, or hybrid cloud scenarios. Transparent, fully automatic WebSocket upgrade support. Transparent, fully automatic gRPC proxy. Sticky session support. HTTP2 ready.","title":"\ud83e\udde0 Notes"},{"location":"assets/api/","text":"\ud83d\udce1 Remote Config API Push new upstreams.yaml over HTTP to config_address ( :3000 by default). Useful for CI/CD automation or remote config updates. URL parameter. key=MASTERKEY is required. MASTERKEY is the value of master_key in the main.yaml curl -XPOST --data-binary @./etc/upstreams.txt 127 .0.0.1:3000/conf?key = ${ MASTERKEY } \ud83d\udce1 Status API Get the list of upstreams with current status. curl 127 .0.0.1:3000/staus?live Example putput { \"mip.domain.com\" : { \"/\" : { \"backends\" : [ { \"address\" : \"127.0.0.1\" , \"alive\" : false , \"port\" : 8000 } ] } }, \"polo.domain.com\" : { \"/\" : { \"backends\" : [ { \"address\" : \"192.168.1.1\" , \"alive\" : true , \"port\" : 8000 } ] } } } Get the full list of configured upstreams with configurations parameters curl 127 .0.0.1:3000/staus?all Example output { \"mip.domain.com\" : { \"/\" : { \"backends\" : [ { \"address\" : \"127.0.0.1\" , \"port\" : 8000 , \"is_ssl\" : false , \"is_http2\" : false , \"to_https\" : false , \"rate_limit\" : 200 , \"healthcheck\" : null } ], \"requests\" : 0 } }, \"polo.domain.com\" : { \"/\" : { \"backends\" : [ { \"address\" : \"192.168.1.1\" , \"port\" : 8000 , \"is_ssl\" : false , \"is_http2\" : false , \"to_https\" : false , \"rate_limit\" : null , \"healthcheck\" : null } ], \"requests\" : 0 } } }","title":"Api"},{"location":"assets/api/#remote-config-api","text":"Push new upstreams.yaml over HTTP to config_address ( :3000 by default). Useful for CI/CD automation or remote config updates. URL parameter. key=MASTERKEY is required. MASTERKEY is the value of master_key in the main.yaml curl -XPOST --data-binary @./etc/upstreams.txt 127 .0.0.1:3000/conf?key = ${ MASTERKEY }","title":"\ud83d\udce1 Remote Config API"},{"location":"assets/api/#status-api","text":"Get the list of upstreams with current status. curl 127 .0.0.1:3000/staus?live Example putput { \"mip.domain.com\" : { \"/\" : { \"backends\" : [ { \"address\" : \"127.0.0.1\" , \"alive\" : false , \"port\" : 8000 } ] } }, \"polo.domain.com\" : { \"/\" : { \"backends\" : [ { \"address\" : \"192.168.1.1\" , \"alive\" : true , \"port\" : 8000 } ] } } } Get the full list of configured upstreams with configurations parameters curl 127 .0.0.1:3000/staus?all Example output { \"mip.domain.com\" : { \"/\" : { \"backends\" : [ { \"address\" : \"127.0.0.1\" , \"port\" : 8000 , \"is_ssl\" : false , \"is_http2\" : false , \"to_https\" : false , \"rate_limit\" : 200 , \"healthcheck\" : null } ], \"requests\" : 0 } }, \"polo.domain.com\" : { \"/\" : { \"backends\" : [ { \"address\" : \"192.168.1.1\" , \"port\" : 8000 , \"is_ssl\" : false , \"is_http2\" : false , \"to_https\" : false , \"rate_limit\" : null , \"healthcheck\" : null } ], \"requests\" : 0 } } }","title":"\ud83d\udce1 Status API"},{"location":"assets/auth/","text":"\ud83d\udd10 Authentication (Optional) Adds authentication to all requests. Only one method can be active at a time. basic : Standard HTTP Basic Authentication requests. apikey : Authentication via x-api-key header, which should match the value in config. jwt : JWT authentication implemented via araleztoken= url parameter. /some/url?araleztoken=TOKEN jwt : JWT authentication implemented via Authorization: Bearer <token> header. To obtain JWT a token, you should send generate request to built in api server's /jwt endpoint. master_key : should match configured masterkey in main.yaml and upstreams.yaml . owner : Just a placeholder, can be anything. valid : Time in minutes during which the generated token will be valid. Example JWT token generation request PAYLOAD = '{ \"master_key\": \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\", \"owner\": \"valod\", \"valid\": 10 }' TOK = ` curl -s -XPOST -H \"Content-Type: application/json\" -d \" $PAYLOAD \" http://127.0.0.1:3000/jwt | cut -d '\"' -f4 ` echo $TOK Example Request with JWT token With Authorization: Bearer header curl -H \"Authorization: Bearer ${ TOK } \" -H 'Host: myip.mydomain.com' http://127.0.0.1:6193/ With URL parameter (Very useful if you want to generate and share temporary links) curl -H 'Host: myip.mydomain.com' \"http://127.0.0.1:6193/?araleztoken= ${ TOK } `\" Example Request with API Key curl -H \"x-api-key: ${ APIKEY } \" --header 'Host: myip.mydomain.com' http://127.0.0.1:6193/ Example Request with Basic Auth curl -u username:password -H 'Host: myip.mydomain.com' http://127.0.0.1:6193/","title":"Authentication"},{"location":"assets/auth/#authentication-optional","text":"Adds authentication to all requests. Only one method can be active at a time. basic : Standard HTTP Basic Authentication requests. apikey : Authentication via x-api-key header, which should match the value in config. jwt : JWT authentication implemented via araleztoken= url parameter. /some/url?araleztoken=TOKEN jwt : JWT authentication implemented via Authorization: Bearer <token> header. To obtain JWT a token, you should send generate request to built in api server's /jwt endpoint. master_key : should match configured masterkey in main.yaml and upstreams.yaml . owner : Just a placeholder, can be anything. valid : Time in minutes during which the generated token will be valid. Example JWT token generation request PAYLOAD = '{ \"master_key\": \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\", \"owner\": \"valod\", \"valid\": 10 }' TOK = ` curl -s -XPOST -H \"Content-Type: application/json\" -d \" $PAYLOAD \" http://127.0.0.1:3000/jwt | cut -d '\"' -f4 ` echo $TOK Example Request with JWT token With Authorization: Bearer header curl -H \"Authorization: Bearer ${ TOK } \" -H 'Host: myip.mydomain.com' http://127.0.0.1:6193/ With URL parameter (Very useful if you want to generate and share temporary links) curl -H 'Host: myip.mydomain.com' \"http://127.0.0.1:6193/?araleztoken= ${ TOK } `\" Example Request with API Key curl -H \"x-api-key: ${ APIKEY } \" --header 'Host: myip.mydomain.com' http://127.0.0.1:6193/ Example Request with Basic Auth curl -u username:password -H 'Host: myip.mydomain.com' http://127.0.0.1:6193/","title":"\ud83d\udd10 Authentication (Optional)"},{"location":"assets/autossl/","text":"\ud83d\udd10 Obtain and Renew SSL/TLS Certificates with Lego Securing your applications with HTTPS is not just a best practice \u2013 it\u2019s essential ! \ud83d\ude80 With Lego , an ACME client and companion of Let\u2019s Encrypt, you can easily obtain and auto-renew SSL/TLS certificates for your domains. This guide will walk you through preparing Aralez for ACME challenges and integrating certificates smoothly. \ud83c\udf0d\ud83d\udd11 \u2699\ufe0f Step 1: Prepare Aralez for ACME Challenge In order to respond to certificate validation requests, you need to expose the path /.well-known/acme-challenge in your upstream configuration. This allows Let\u2019s Encrypt (or another ACME CA) to verify that you own the domain. Edit main.yaml and set correct folder to proxy_certificates proxy_certificates: /path/to/certificates/for/aralez/ Basic settings in main.yaml requires restart of Aralez. Edit upstreams.yaml . Here\u2019s a sample configuration: myhost.mydomain.com : paths : \"/\" : headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" servers : - \"127.0.0.1:8000\" - \"127.0.0.2:8000\" \"/.well-known/acme-challenge\" : healthcheck : false servers : - \"127.0.0.1:8899\" \u2728 Important Notes: healthcheck: false ensures Aralez does not remove the ephemeral upstreams (temporary validation servers) from the proxy pool. Once saved, Aralez watch and auto-reload upstreams.yaml \ud83d\udd04 \u2013 no manual restart needed! \ud83d\udce5 Step 2: Download and Install Lego Getting Lego installed is a breeze! \ud83e\ude84 Visit the official releases page . Download the precompiled binary for your OS. Extract it (untar if necessary). Make the binary executable: chmod +x lego Move it into your $PATH (e.g., /usr/local/bin): sudo mv lego /usr/local/bin/ \ud83d\udcdc Step 3: Request Certificates Use Lego to request SSL certificates for one or more domain cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site3.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --http.port = 127 .0.0.1:8899 --http run \ud83d\udd0e What happens here? --key-type \u2192 sets the type of cryptographic key (RSA 2048 in this case). --domains \u2192 add one or multiple domains you want to secure. --email \u2192 your contact email (used by Let\u2019s Encrypt). --http.port \u2192 the local port Lego will bind for the HTTP challenge. --accept-tos \u2192 Accept Let's Encrypt terms of service. (default: false). Certificates will be created in the ./.lego/certificates/ directory. \ud83d\uddc2\ufe0f \ud83d\udd17 Step 4: Make Certificates Usable for Aralez Combine and copy the certificates into a path where Aralez expects them: cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key \ud83d\udca1 Pro tip: Instead of manual steps, you can automate with Lego\u2019s built-in hook system using --run-hook. More details: Lego CLI Docs \ud83d\udcda \ud83c\udf89 Step 5: Automatic Reload with Aralez The magic part \u2728 \u2013 Aralez automatically detects changes to your certificates and reloads them on the fly. No downtime. No hassle . Just pure HTTPS goodness. \ud83d\udd12\ud83d\ude80 \ud83d\udca1 Important tip: Aralez expects certificates and keys to follow a specific naming convention: Certificate files must have the .crt extension. Private key files must have the .key extension. Matching .crt and .key files must share the same filename prefix. \ud83d\udcc2 Example: example.com.crt example.com.key \ud83d\udd0e The exact prefix doesn\u2019t matter (it can be any string), but it must be unique per certificate. Aralez scans the certificate and key files, then matches them in memory by content. This ensures the correct pairs are always loaded together. \ud83d\udcdc Step 5: Renewing certificates The easiest is to create a tiny wrapper bash script and put it in crontab. #!/bin/bash cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site3.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --http.port = 127 .0.0.1:8899 --http $1 cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key Crontab entry 0 9 * * * /path/to/lego.sh renew \u2699\ufe0f Using ZeroSSL instead of Let's Encrypt Create an account at ZeroSSL. Login to web app, go to Developer Generate and save your KID and HMAC Create a wrapper script: lego.sh #!/bin/bash cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site1.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --server \"https://acme.zerossl.com/v2/DV90\" \\ --eab --kid \" $YOUR_KID \" \\ --hmac \" $YOUR_HMAC \" \\ --http.port = 127 .0.0.1:8899 --http $1 cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key \ud83d\udd0e What is changed here? --servers \u2192 The URL to ZeroSSL Server. --eab \u2192 EAB copied from developer section of ZeroSSL web app. --hmac \u2192 HMAC copied from developer section of ZeroSSL web app. Obtain the certificate ./lego.sh run Renew the certificate ./lego.sh renew","title":"Manage Certificates"},{"location":"assets/autossl/#obtain-and-renew-ssltls-certificates-with-lego","text":"Securing your applications with HTTPS is not just a best practice \u2013 it\u2019s essential ! \ud83d\ude80 With Lego , an ACME client and companion of Let\u2019s Encrypt, you can easily obtain and auto-renew SSL/TLS certificates for your domains. This guide will walk you through preparing Aralez for ACME challenges and integrating certificates smoothly. \ud83c\udf0d\ud83d\udd11","title":"\ud83d\udd10 Obtain and Renew SSL/TLS Certificates with Lego"},{"location":"assets/autossl/#step-1-prepare-aralez-for-acme-challenge","text":"In order to respond to certificate validation requests, you need to expose the path /.well-known/acme-challenge in your upstream configuration. This allows Let\u2019s Encrypt (or another ACME CA) to verify that you own the domain. Edit main.yaml and set correct folder to proxy_certificates proxy_certificates: /path/to/certificates/for/aralez/ Basic settings in main.yaml requires restart of Aralez. Edit upstreams.yaml . Here\u2019s a sample configuration: myhost.mydomain.com : paths : \"/\" : headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" servers : - \"127.0.0.1:8000\" - \"127.0.0.2:8000\" \"/.well-known/acme-challenge\" : healthcheck : false servers : - \"127.0.0.1:8899\" \u2728 Important Notes: healthcheck: false ensures Aralez does not remove the ephemeral upstreams (temporary validation servers) from the proxy pool. Once saved, Aralez watch and auto-reload upstreams.yaml \ud83d\udd04 \u2013 no manual restart needed!","title":"\u2699\ufe0f Step 1: Prepare Aralez for ACME Challenge"},{"location":"assets/autossl/#step-2-download-and-install-lego","text":"Getting Lego installed is a breeze! \ud83e\ude84 Visit the official releases page . Download the precompiled binary for your OS. Extract it (untar if necessary). Make the binary executable: chmod +x lego Move it into your $PATH (e.g., /usr/local/bin): sudo mv lego /usr/local/bin/","title":"\ud83d\udce5 Step 2: Download and Install Lego"},{"location":"assets/autossl/#step-3-request-certificates","text":"Use Lego to request SSL certificates for one or more domain cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site3.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --http.port = 127 .0.0.1:8899 --http run","title":"\ud83d\udcdc Step 3: Request Certificates"},{"location":"assets/autossl/#what-happens-here","text":"--key-type \u2192 sets the type of cryptographic key (RSA 2048 in this case). --domains \u2192 add one or multiple domains you want to secure. --email \u2192 your contact email (used by Let\u2019s Encrypt). --http.port \u2192 the local port Lego will bind for the HTTP challenge. --accept-tos \u2192 Accept Let's Encrypt terms of service. (default: false). Certificates will be created in the ./.lego/certificates/ directory. \ud83d\uddc2\ufe0f","title":"\ud83d\udd0e What happens here?"},{"location":"assets/autossl/#step-4-make-certificates-usable-for-aralez","text":"Combine and copy the certificates into a path where Aralez expects them: cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key \ud83d\udca1 Pro tip: Instead of manual steps, you can automate with Lego\u2019s built-in hook system using --run-hook. More details: Lego CLI Docs \ud83d\udcda","title":"\ud83d\udd17 Step 4: Make Certificates Usable for Aralez"},{"location":"assets/autossl/#step-5-automatic-reload-with-aralez","text":"The magic part \u2728 \u2013 Aralez automatically detects changes to your certificates and reloads them on the fly. No downtime. No hassle . Just pure HTTPS goodness. \ud83d\udd12\ud83d\ude80 \ud83d\udca1 Important tip: Aralez expects certificates and keys to follow a specific naming convention: Certificate files must have the .crt extension. Private key files must have the .key extension. Matching .crt and .key files must share the same filename prefix. \ud83d\udcc2 Example: example.com.crt example.com.key \ud83d\udd0e The exact prefix doesn\u2019t matter (it can be any string), but it must be unique per certificate. Aralez scans the certificate and key files, then matches them in memory by content. This ensures the correct pairs are always loaded together.","title":"\ud83c\udf89 Step 5: Automatic Reload with Aralez"},{"location":"assets/autossl/#step-5-renewing-certificates","text":"The easiest is to create a tiny wrapper bash script and put it in crontab. #!/bin/bash cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site3.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --http.port = 127 .0.0.1:8899 --http $1 cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key Crontab entry 0 9 * * * /path/to/lego.sh renew","title":"\ud83d\udcdc Step 5: Renewing certificates"},{"location":"assets/autossl/#using-zerossl-instead-of-lets-encrypt","text":"Create an account at ZeroSSL. Login to web app, go to Developer Generate and save your KID and HMAC Create a wrapper script: lego.sh #!/bin/bash cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site1.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --server \"https://acme.zerossl.com/v2/DV90\" \\ --eab --kid \" $YOUR_KID \" \\ --hmac \" $YOUR_HMAC \" \\ --http.port = 127 .0.0.1:8899 --http $1 cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key","title":"\u2699\ufe0f Using ZeroSSL instead of Let's Encrypt"},{"location":"assets/autossl/#what-is-changed-here","text":"--servers \u2192 The URL to ZeroSSL Server. --eab \u2192 EAB copied from developer section of ZeroSSL web app. --hmac \u2192 HMAC copied from developer section of ZeroSSL web app. Obtain the certificate ./lego.sh run Renew the certificate ./lego.sh renew","title":"\ud83d\udd0e What is changed here?"},{"location":"assets/compare/","text":"\ud83e\udde9 Feature Comparison Feature / Proxy Aralez Nginx HAProxy Traefik Caddy Envoy Hot Reload (Zero Downtime) \u2705 Automatic \u2699\ufe0f Manual (graceful reload) \u2699\ufe0f Manual \u2705 Automatic \u2705 Automatic \u2705 Automatic Auto Cert Reload (from disk) \u2705 Automatic \u274c No \u274c No \u2705 Automatic (Let's Encrypt only) \u2705 Automatic \u2699\ufe0f Manual Auth: Basic / API Key / JWT \u2705 Built-in \u2699\ufe0f Basic only \u2699\ufe0f Basic only \u2705 Config-based \u2705 Config-based \u2705 Config-based TLS / HTTP2 Termination \u2705 Automatic \u2699\ufe0f Manual config \u2699\ufe0f Manual config \u2705 Automatic \u2705 Automatic \u2705 Automatic Built-in A+ TLS Grades \u2705 Automatic \u2699\ufe0f Manual tuning \u2699\ufe0f Manual \u2699\ufe0f Manual \u2705 Automatic \u2699\ufe0f Manual gRPC Proxy \u2705 Zero-Config \u2699\ufe0f Manual setup \u2699\ufe0f Manual \u2699\ufe0f Needs config \u2699\ufe0f Needs config \u2699\ufe0f Needs config SSL Proxy \u2705 Zero-Config \u2699\ufe0f Manual \u2699\ufe0f Manual \u2705 Automatic \u2705 Automatic \u2705 Automatic HTTP/2 Proxy \u2705 Zero-Config \u2699\ufe0f Manual enable \u2699\ufe0f Manual enable \u2705 Automatic \u2705 Automatic \u2705 Automatic WebSocket Proxy \u2705 Zero-Config \u2699\ufe0f Manual upgrade \u2699\ufe0f Manual upgrade \u2705 Automatic \u2705 Automatic \u2705 Automatic Sticky Sessions \u2705 Built-in \u2699\ufe0f Config-based \u2699\ufe0f Config-based \u2705 Automatic \u2699\ufe0f Limited \u2705 Config-based Prometheus Metrics \u2705 Built-in \u2699\ufe0f External exporter \u2705 Built-in \u2705 Built-in \u2705 Built-in \u2705 Built-in Consul Integration \u2705 Yes \u274c No \u2699\ufe0f Via DNS only \u2705 Yes \u274c No \u2705 Yes Kubernetes Integration \u2705 Yes \u2699\ufe0f Needs ingress setup \u2699\ufe0f External \u2705 Yes \u2699\ufe0f Limited \u2705 Yes Request Limiter \u2705 Yes \u2705 Config-based \u2705 Config-based \u2705 Config-based \u2705 Config-based \u2705 Config-based Serve Static Files \u2705 Yes \u2705 Yes \u2699\ufe0f Basic \u2705 Automatic \u2705 Automatic \u274c No Upstream Health Checks \u2705 Automatic \u2699\ufe0f Manual config \u2699\ufe0f Manual config \u2705 Automatic \u2705 Automatic \u2705 Automatic Built With \ud83e\udd80 Rust C C Go Go C++ \u2705 Automatic / Zero-Config \u2013 Works immediately, no setup required \u2699\ufe0f Manual / Config-based \u2013 Requires explicit configuration or modules \u274c No \u2013 Not supported \ud83d\udca1 Interpretation Aralez aims to combine the simplicity of NGINX , the observability of Envoy , and the dynamic features of Traefik , all in a modern, lightweight Rust codebase. Where most proxies require external tooling or complex configuration for dynamic updates, Aralez focuses on automatic behavior by default : - Upstreams and certificates reload instantly with zero downtime. - Health checks, TLS termination, and protocol upgrades happen automatically. - Authentication and metrics are built-in, not bolted on. - Consul and Kubernetes integration make it mesh-ready without extra agents. - Written in safe, high-performance Rust , offering reliability and modern concurrency. In short, Aralez is designed for developers and operators who want a fast, self-contained reverse proxy that \u201cjust works,\u201d while still being flexible enough to scale into a service-mesh-like architecture. \u26a1 Zero-Config Features Aralez is designed to just work out of the box , minimizing setup and manual configuration. With Aralez, you get: Automatic protocol detection: gRPC, HTTP/2, WebSockets, and SSL are proxied correctly without extra config. Hot reloads & zero downtime: Upstreams and configuration changes take effect immediately without restarting the server. Automatic TLS / certificate updates: Drop new certificates on disk and Aralez picks them up instantly. Built-in authentication & rate limiting: Basic auth, API key, JWT, and request limits are ready-to-use. Observability & metrics: Prometheus metrics are available automatically. Service discovery integration: Works seamlessly with Consul and Kubernetes DNS without extra setup. In short, Aralez is a modern reverse proxy that configures itself around your environment , so you can focus on building and deploying apps \u2014 not managing your proxy.","title":"Comparition"},{"location":"assets/compare/#feature-comparison","text":"Feature / Proxy Aralez Nginx HAProxy Traefik Caddy Envoy Hot Reload (Zero Downtime) \u2705 Automatic \u2699\ufe0f Manual (graceful reload) \u2699\ufe0f Manual \u2705 Automatic \u2705 Automatic \u2705 Automatic Auto Cert Reload (from disk) \u2705 Automatic \u274c No \u274c No \u2705 Automatic (Let's Encrypt only) \u2705 Automatic \u2699\ufe0f Manual Auth: Basic / API Key / JWT \u2705 Built-in \u2699\ufe0f Basic only \u2699\ufe0f Basic only \u2705 Config-based \u2705 Config-based \u2705 Config-based TLS / HTTP2 Termination \u2705 Automatic \u2699\ufe0f Manual config \u2699\ufe0f Manual config \u2705 Automatic \u2705 Automatic \u2705 Automatic Built-in A+ TLS Grades \u2705 Automatic \u2699\ufe0f Manual tuning \u2699\ufe0f Manual \u2699\ufe0f Manual \u2705 Automatic \u2699\ufe0f Manual gRPC Proxy \u2705 Zero-Config \u2699\ufe0f Manual setup \u2699\ufe0f Manual \u2699\ufe0f Needs config \u2699\ufe0f Needs config \u2699\ufe0f Needs config SSL Proxy \u2705 Zero-Config \u2699\ufe0f Manual \u2699\ufe0f Manual \u2705 Automatic \u2705 Automatic \u2705 Automatic HTTP/2 Proxy \u2705 Zero-Config \u2699\ufe0f Manual enable \u2699\ufe0f Manual enable \u2705 Automatic \u2705 Automatic \u2705 Automatic WebSocket Proxy \u2705 Zero-Config \u2699\ufe0f Manual upgrade \u2699\ufe0f Manual upgrade \u2705 Automatic \u2705 Automatic \u2705 Automatic Sticky Sessions \u2705 Built-in \u2699\ufe0f Config-based \u2699\ufe0f Config-based \u2705 Automatic \u2699\ufe0f Limited \u2705 Config-based Prometheus Metrics \u2705 Built-in \u2699\ufe0f External exporter \u2705 Built-in \u2705 Built-in \u2705 Built-in \u2705 Built-in Consul Integration \u2705 Yes \u274c No \u2699\ufe0f Via DNS only \u2705 Yes \u274c No \u2705 Yes Kubernetes Integration \u2705 Yes \u2699\ufe0f Needs ingress setup \u2699\ufe0f External \u2705 Yes \u2699\ufe0f Limited \u2705 Yes Request Limiter \u2705 Yes \u2705 Config-based \u2705 Config-based \u2705 Config-based \u2705 Config-based \u2705 Config-based Serve Static Files \u2705 Yes \u2705 Yes \u2699\ufe0f Basic \u2705 Automatic \u2705 Automatic \u274c No Upstream Health Checks \u2705 Automatic \u2699\ufe0f Manual config \u2699\ufe0f Manual config \u2705 Automatic \u2705 Automatic \u2705 Automatic Built With \ud83e\udd80 Rust C C Go Go C++ \u2705 Automatic / Zero-Config \u2013 Works immediately, no setup required \u2699\ufe0f Manual / Config-based \u2013 Requires explicit configuration or modules \u274c No \u2013 Not supported","title":"\ud83e\udde9 Feature Comparison"},{"location":"assets/compare/#interpretation","text":"Aralez aims to combine the simplicity of NGINX , the observability of Envoy , and the dynamic features of Traefik , all in a modern, lightweight Rust codebase. Where most proxies require external tooling or complex configuration for dynamic updates, Aralez focuses on automatic behavior by default : - Upstreams and certificates reload instantly with zero downtime. - Health checks, TLS termination, and protocol upgrades happen automatically. - Authentication and metrics are built-in, not bolted on. - Consul and Kubernetes integration make it mesh-ready without extra agents. - Written in safe, high-performance Rust , offering reliability and modern concurrency. In short, Aralez is designed for developers and operators who want a fast, self-contained reverse proxy that \u201cjust works,\u201d while still being flexible enough to scale into a service-mesh-like architecture.","title":"\ud83d\udca1 Interpretation"},{"location":"assets/compare/#zero-config-features","text":"Aralez is designed to just work out of the box , minimizing setup and manual configuration. With Aralez, you get: Automatic protocol detection: gRPC, HTTP/2, WebSockets, and SSL are proxied correctly without extra config. Hot reloads & zero downtime: Upstreams and configuration changes take effect immediately without restarting the server. Automatic TLS / certificate updates: Drop new certificates on disk and Aralez picks them up instantly. Built-in authentication & rate limiting: Basic auth, API key, JWT, and request limits are ready-to-use. Observability & metrics: Prometheus metrics are available automatically. Service discovery integration: Works seamlessly with Consul and Kubernetes DNS without extra setup. In short, Aralez is a modern reverse proxy that configures itself around your environment , so you can focus on building and deploying apps \u2014 not managing your proxy.","title":"\u26a1 Zero-Config Features"},{"location":"assets/config/","text":"\ud83d\udee0 Configuration Overview \ud83d\udd27 main.yaml Key Example Value Description threads 12 Number of running daemon threads. Optional, defaults to 1 runuser aralez Optional, Username for running aralez after dropping root privileges, requires to launch as root rungroup aralez Optional,Group for running aralez after dropping root privileges, requires to launch as root daemon false Run in background (boolean) upstream_keepalive_pool_size 500 Pool size for upstream keepalive connections pid_file /tmp/aralez.pid Path to PID file error_log /tmp/aralez_err.log Path to error log file config_address 0.0.0.0:3000 HTTP API address for pushing upstreams.yaml from remote location config_tls_address 0.0.0.0:3001 HTTPS API address for pushing upstreams.yaml from remote location config_tls_certificate etc/server.crt Certificate file path for API. Mandatory if proxy_address_tls is set, else optional proxy_tls_grade (high, medium, unsafe) Grade of TLS ciphers, for easy configuration. High matches Qualys SSL Labs A+ (defaults to medium) config_tls_key_file etc/key.pem Private Key file path. Mandatory if proxy_address_tls is set, else optional proxy_address_http 0.0.0.0:6193 Aralez HTTP bind address proxy_address_tls 0.0.0.0:6194 Aralez HTTPS bind address (Optional) proxy_certificates etc/certs/ The directory containing certificate and key files. In a format {NAME}.crt, {NAME}.key. upstreams_conf etc/upstreams.yaml The location of upstreams file log_level info Log level , possible values : info, warn, error, debug, trace, off hc_method HEAD Healthcheck method (HEAD, GET, POST are supported) UPPERCASE hc_interval 2 Interval for health checks in seconds master_key 5aeff7f9-7b94-447c-af60-e8c488544a3e Master key for working with API server and JWT Secret generation file_server_folder /some/local/folder Optional, local folder to serve file_server_address 127.0.0.1:3002 Optional, Local address for file server. Can set as upstream for public access config_api_enabled true Boolean to enable/disable remote config push capability \ud83c\udf10 upstreams.yaml provider : file or consul File-based upstreams define: Hostnames and routing paths Backend servers (load-balanced) Optional request headers, specific to this upstream Global headers (e.g., CORS) apply to all proxied responses Optional authentication (Basic, API Key, JWT) \ud83d\udca1 Example A sample upstreams.yaml entry: provider : \"file\" sticky_sessions : false to_https : false rate_limit : 10 server_headers : - \"X-Forwarded-Proto:https\" - \"X-Forwarded-Port:443\" client_headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" authorization : type : \"jwt\" creds : \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\" myhost.mydomain.com : paths : \"/\" : rate_limit : 20 to_https : false server_headers : - \"X-Something-Else:Foobar\" - \"X-Another-Header:Hohohohoho\" client_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Hopaaaaaaaaaaaar\" servers : - \"127.0.0.1:8000\" - \"127.0.0.2:8000\" \"/foo\" : to_https : true client_headers : - \"X-Another-Header:Hohohohoho\" servers : - \"127.0.0.4:8443\" - \"127.0.0.5:8443\" \"/.well-known/acme-challenge\" : healthcheck : false servers : - \"127.0.0.1:8001\" This means: Sticky sessions are disabled globally. This setting applies to all upstreams. If enabled all requests will be 301 redirected to HTTPS. HTTP to HTTPS redirect disabled globally, but can be overridden by to_https setting per upstream. All upstreams will receive custom headers : X-Forwarded-Proto:https and X-Forwarded-Port:443 Additionally myhost,mydomain.com with path / will receive custom headers : X-Another-Header:Hohohohoho and X-Something-Else:Foobar Requests to each hosted domains will be limited to 10 requests per second per virtualhost. Requests limits are calculated per requester ip plus requested virtualhost. If the requester exceeds the limit it will receive 429 Too Many Requests error. Optional. Rate limiter will be disabled if the parameter is entirely removed from config. Requests to myhost.mydomain.com/ will be limited to 20 requests per second. Requests to myhost.mydomain.com/ will be proxied to 127.0.0.1 and 127.0.0.2 . Plain HTTP to myhost.mydomain.com/foo will get 301 redirect to configured TLS port of Aralez. Requests to myhost.mydomain.com/foo will be proxied to 127.0.0.4 and 127.0.0.5 . Requests to myhost.mydomain.com/.well-known/acme-challenge will be proxied to 127.0.0.1:8001 , but healthcheks are disabled. SSL/TLS for upstreams is detected automatically, no need to set any config parameter. Assuming the 127.0.0.5:8443 is SSL protected. The inner traffic will use TLS. Self-signed certificates are silently accepted. Global headers (CORS for this case) will be injected to all upstreams. Additional headers will be injected into the request for myhost.mydomain.com . You can choose any path, deep nested paths are supported, the best match chosen. All requests to servers will require JWT token authentication (You can comment out the authorization to disable it), Firs parameter specifies the mechanism of authorisation jwt Second is the secret key for validating jwt tokens \ud83d\udca1 For Kubernetes and Consul provider provider : \"kubernetes\" # \"consul\" \"kubernetes\" sticky_sessions : false to_https : false rate_limit : 100 server_headers : - \"X-Forwarded-Proto:https\" - \"X-Forwarded-Port:443\" client_headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" consul : servers : - \"http://consul1:8500\" services : # hostname: The hostname to access the proxy server, upstream : The real service name in Consul database. - hostname : \"nconsul\" upstream : \"nginx-consul-NginX-health\" path : \"/one\" client_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 1 to_https : false - hostname : \"nconsul\" upstream : \"nginx-consul-NginX-health\" path : \"/\" token : \"8e2db809-845b-45e1-8b47-2c8356a09da0-a4370955-18c2-4d6e-a8f8-ffcc0b47be81\" # Consul server access token, If Consul auth is enabled kubernetes : servers : - \"172.16.0.11:5443\" # Gets KUBERNETES_SERVICE_HOST : KUBERNETES_SERVICE_PORT_HTTPS env variables. services : - hostname : \"api-service\" path : \"/\" upstream : \"api-service\" - hostname : \"api-service\" upstream : \"console-service\" path : \"/one\" client_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 100 to_https : false - hostname : \"api-service\" upstream : \"feed-service\" path : \"/two\" - hostname : \"websocket-service\" upstream : \"websocket-service\" path : \"/\" tokenpath : \"/opt/Rust/Projects/asyncweb/etc/kubetoken.txt\" # Defaults to /var/run/secrets/kubernetes.io/serviceaccount/token The yaml structure of Consul and Kubernetes providers is different. Each section contains mandatory and optional fields. Mandatory Fields: - hostname : \"api-service\" upstream : \"api-service\" Where hostname is actually the Host header to access the service and upstream is a service name in Consul or Kubernetes. Optional Fields: path : \"/one\" client_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" server_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 100 to_https : false Optional parameters defaults to None , if not set path: Url path to proxy to upstreams client_headers: List of additional headers server_headers: List of additional headers for upstreams rate_limit: Rate limiter, number per second to_https: Redirect to HTTPS Consul only token : \"8e2db809-845b-45e1-8b47-2c8356a09da0-a4370955-18c2-4d6e-a8f8-ffcc0b47be81\" If authentication is enabled this parameter should be the Consul auth token. Default None , mandatory if Consul auth is enabled servers : - \"http://consul1:8500\" The list of Consul servers. Mandatory for Consul Kubernetes only tokenpath : \"/opt/Rust/Projects/asyncweb/etc/kubetoken.txt For development propose only. Default to /var/run/secrets/kubernetes.io/serviceaccount/token . Remove iot for production use. servers : - \"172.16.0.11:5443\" Defaults to the following environment variables. KUBERNETES_SERVICE_HOST KUBERNETES_SERVICE_PORT_HTTPS For development propose only. Delete for production use.","title":"Config"},{"location":"assets/config/#configuration-overview","text":"","title":"\ud83d\udee0 Configuration Overview"},{"location":"assets/config/#mainyaml","text":"Key Example Value Description threads 12 Number of running daemon threads. Optional, defaults to 1 runuser aralez Optional, Username for running aralez after dropping root privileges, requires to launch as root rungroup aralez Optional,Group for running aralez after dropping root privileges, requires to launch as root daemon false Run in background (boolean) upstream_keepalive_pool_size 500 Pool size for upstream keepalive connections pid_file /tmp/aralez.pid Path to PID file error_log /tmp/aralez_err.log Path to error log file config_address 0.0.0.0:3000 HTTP API address for pushing upstreams.yaml from remote location config_tls_address 0.0.0.0:3001 HTTPS API address for pushing upstreams.yaml from remote location config_tls_certificate etc/server.crt Certificate file path for API. Mandatory if proxy_address_tls is set, else optional proxy_tls_grade (high, medium, unsafe) Grade of TLS ciphers, for easy configuration. High matches Qualys SSL Labs A+ (defaults to medium) config_tls_key_file etc/key.pem Private Key file path. Mandatory if proxy_address_tls is set, else optional proxy_address_http 0.0.0.0:6193 Aralez HTTP bind address proxy_address_tls 0.0.0.0:6194 Aralez HTTPS bind address (Optional) proxy_certificates etc/certs/ The directory containing certificate and key files. In a format {NAME}.crt, {NAME}.key. upstreams_conf etc/upstreams.yaml The location of upstreams file log_level info Log level , possible values : info, warn, error, debug, trace, off hc_method HEAD Healthcheck method (HEAD, GET, POST are supported) UPPERCASE hc_interval 2 Interval for health checks in seconds master_key 5aeff7f9-7b94-447c-af60-e8c488544a3e Master key for working with API server and JWT Secret generation file_server_folder /some/local/folder Optional, local folder to serve file_server_address 127.0.0.1:3002 Optional, Local address for file server. Can set as upstream for public access config_api_enabled true Boolean to enable/disable remote config push capability","title":"\ud83d\udd27 main.yaml"},{"location":"assets/config/#upstreamsyaml","text":"provider : file or consul File-based upstreams define: Hostnames and routing paths Backend servers (load-balanced) Optional request headers, specific to this upstream Global headers (e.g., CORS) apply to all proxied responses Optional authentication (Basic, API Key, JWT)","title":"\ud83c\udf10 upstreams.yaml"},{"location":"assets/config/#example","text":"A sample upstreams.yaml entry: provider : \"file\" sticky_sessions : false to_https : false rate_limit : 10 server_headers : - \"X-Forwarded-Proto:https\" - \"X-Forwarded-Port:443\" client_headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" authorization : type : \"jwt\" creds : \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\" myhost.mydomain.com : paths : \"/\" : rate_limit : 20 to_https : false server_headers : - \"X-Something-Else:Foobar\" - \"X-Another-Header:Hohohohoho\" client_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Hopaaaaaaaaaaaar\" servers : - \"127.0.0.1:8000\" - \"127.0.0.2:8000\" \"/foo\" : to_https : true client_headers : - \"X-Another-Header:Hohohohoho\" servers : - \"127.0.0.4:8443\" - \"127.0.0.5:8443\" \"/.well-known/acme-challenge\" : healthcheck : false servers : - \"127.0.0.1:8001\" This means: Sticky sessions are disabled globally. This setting applies to all upstreams. If enabled all requests will be 301 redirected to HTTPS. HTTP to HTTPS redirect disabled globally, but can be overridden by to_https setting per upstream. All upstreams will receive custom headers : X-Forwarded-Proto:https and X-Forwarded-Port:443 Additionally myhost,mydomain.com with path / will receive custom headers : X-Another-Header:Hohohohoho and X-Something-Else:Foobar Requests to each hosted domains will be limited to 10 requests per second per virtualhost. Requests limits are calculated per requester ip plus requested virtualhost. If the requester exceeds the limit it will receive 429 Too Many Requests error. Optional. Rate limiter will be disabled if the parameter is entirely removed from config. Requests to myhost.mydomain.com/ will be limited to 20 requests per second. Requests to myhost.mydomain.com/ will be proxied to 127.0.0.1 and 127.0.0.2 . Plain HTTP to myhost.mydomain.com/foo will get 301 redirect to configured TLS port of Aralez. Requests to myhost.mydomain.com/foo will be proxied to 127.0.0.4 and 127.0.0.5 . Requests to myhost.mydomain.com/.well-known/acme-challenge will be proxied to 127.0.0.1:8001 , but healthcheks are disabled. SSL/TLS for upstreams is detected automatically, no need to set any config parameter. Assuming the 127.0.0.5:8443 is SSL protected. The inner traffic will use TLS. Self-signed certificates are silently accepted. Global headers (CORS for this case) will be injected to all upstreams. Additional headers will be injected into the request for myhost.mydomain.com . You can choose any path, deep nested paths are supported, the best match chosen. All requests to servers will require JWT token authentication (You can comment out the authorization to disable it), Firs parameter specifies the mechanism of authorisation jwt Second is the secret key for validating jwt tokens","title":"\ud83d\udca1 Example"},{"location":"assets/config/#for-kubernetes-and-consul-provider","text":"provider : \"kubernetes\" # \"consul\" \"kubernetes\" sticky_sessions : false to_https : false rate_limit : 100 server_headers : - \"X-Forwarded-Proto:https\" - \"X-Forwarded-Port:443\" client_headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" consul : servers : - \"http://consul1:8500\" services : # hostname: The hostname to access the proxy server, upstream : The real service name in Consul database. - hostname : \"nconsul\" upstream : \"nginx-consul-NginX-health\" path : \"/one\" client_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 1 to_https : false - hostname : \"nconsul\" upstream : \"nginx-consul-NginX-health\" path : \"/\" token : \"8e2db809-845b-45e1-8b47-2c8356a09da0-a4370955-18c2-4d6e-a8f8-ffcc0b47be81\" # Consul server access token, If Consul auth is enabled kubernetes : servers : - \"172.16.0.11:5443\" # Gets KUBERNETES_SERVICE_HOST : KUBERNETES_SERVICE_PORT_HTTPS env variables. services : - hostname : \"api-service\" path : \"/\" upstream : \"api-service\" - hostname : \"api-service\" upstream : \"console-service\" path : \"/one\" client_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 100 to_https : false - hostname : \"api-service\" upstream : \"feed-service\" path : \"/two\" - hostname : \"websocket-service\" upstream : \"websocket-service\" path : \"/\" tokenpath : \"/opt/Rust/Projects/asyncweb/etc/kubetoken.txt\" # Defaults to /var/run/secrets/kubernetes.io/serviceaccount/token The yaml structure of Consul and Kubernetes providers is different. Each section contains mandatory and optional fields.","title":"\ud83d\udca1 For Kubernetes and Consul provider"},{"location":"assets/config/#mandatory-fields","text":"- hostname : \"api-service\" upstream : \"api-service\" Where hostname is actually the Host header to access the service and upstream is a service name in Consul or Kubernetes.","title":"Mandatory Fields:"},{"location":"assets/config/#optional-fields","text":"path : \"/one\" client_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" server_headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 100 to_https : false Optional parameters defaults to None , if not set path: Url path to proxy to upstreams client_headers: List of additional headers server_headers: List of additional headers for upstreams rate_limit: Rate limiter, number per second to_https: Redirect to HTTPS","title":"Optional Fields:"},{"location":"assets/config/#consul-only","text":"token : \"8e2db809-845b-45e1-8b47-2c8356a09da0-a4370955-18c2-4d6e-a8f8-ffcc0b47be81\" If authentication is enabled this parameter should be the Consul auth token. Default None , mandatory if Consul auth is enabled servers : - \"http://consul1:8500\" The list of Consul servers. Mandatory for Consul","title":"Consul only"},{"location":"assets/config/#kubernetes-only","text":"tokenpath : \"/opt/Rust/Projects/asyncweb/etc/kubetoken.txt For development propose only. Default to /var/run/secrets/kubernetes.io/serviceaccount/token . Remove iot for production use. servers : - \"172.16.0.11:5443\" Defaults to the following environment variables. KUBERNETES_SERVICE_HOST KUBERNETES_SERVICE_PORT_HTTPS For development propose only. Delete for production use.","title":"Kubernetes only"},{"location":"assets/kubernetes/","text":"\ud83d\udcc8 Aralez & Kubernetes Integration Guide This guide walks you through setting up Aralez to run smoothly inside a Kubernetes cluster as a lightweight service mesh. We\u2019ll create the necessary ServiceAccount , apply the right RBAC roles , and then deploy Aralez as a Kubernetes Deployment with an exposed Service. \ud83d\udd11 Step 1: Create a Service Account Aralez needs a ServiceAccount with permissions to watch Kubernetes resources like pods, endpoints, and services. You can define it in YAML: apiVersion : v1 kind : ServiceAccount metadata : name : aralez-sa \ud83d\udcdc Step 2: Define RBAC Permissions Aralez requires read-only access to Kubernetes resources within a namespace. Role (scoped to a single namespace): apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : aralez-role rules : - apiGroups : [ \"\" ] resources : [ \"pods\" , \"endpoints\" , \"services\" ] verbs : [ \"get\" , \"list\" , \"watch\" ] RoleBinding (attach Role to the ServiceAccount): apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : aralez-binding subjects : - kind : ServiceAccount name : aralez-sa roleRef : kind : Role name : aralez-role apiGroup : rbac.authorization.k8s.io \ud83d\ude80 Step 3: Deploy Aralez Here\u2019s a minimal deployment example for running Aralez in your cluster. Configs \u2192 ConfigMap. Arbitrary configs like main.yaml, upstreams.yml, etc. Example :main.yml threads : 12 daemon : false upstream_keepalive_pool_size : 500 pid_file : /tmp/aralez.pid error_log : /tmp/aralez_err.log upgrade_sock : /tmp/aralez.sock config_api_enabled : false config_address : 127.0.0.1:3000 proxy_address_http : 0.0.0.0:80 proxy_address_tls : 0.0.0.0:443 proxy_certificates : /etc/aralez/certs proxy_tls_grade : high upstreams_conf : /etc/aralez/config/upstreams.yml log_level : info hc_method : HEAD hc_interval : 2 master_key : 910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774 Example :upstreams.yml provider : \"kubernetes\" sticky_sessions : false to_https : false rate_limit : 100 headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" - \"Strict-Transport-Security:max-age=31536000; includeSubDomains; preload\" #authorization: # type: \"jwt\" # creds: \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\" # type: \"basic\" # creds: \"username:Passw0rd\" # type: \"apikey\" # creds: \"5ecbf799-1343-4e94-a9b5-e278af5cd313-56b45249-1839-4008-a450-a60dc76d2bae\" kubernetes : services : - hostname : \"vt-webapi-service\" path : \"/\" upstream : \"vt-webapi-service\" - hostname : \"vt-webapi-service\" upstream : \"vt-console-service\" path : \"/one\" headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 100 to_https : false - hostname : \"vt-webapi-service\" upstream : \"vt-rambulik-service\" path : \"/two\" - hostname : \"vt-websocket-service\" upstream : \"vt-websocket-service\" path : \"/\" tokenpath : \"/var/run/secrets/kubernetes.io/serviceaccount/token\" Apply config maps kubectl -n staging create configmap aralez-main-config --from-file = main.yaml = ./main.yaml kubectl -n staging create configmap aralez-upstreams-config --from-file = upstreams.yml = ./upstreams.yaml Create certificate and private key secrets for TLS apiVersion : v1 kind : Secret metadata : name : aralez-tls type : kubernetes.io/tls data : tls.crt : <base64-cert> tls.key : <base64-key> Deployment Aralez Example :deployment.yaml apiVersion : apps/v1 kind : Deployment metadata : name : aralez spec : replicas : 1 selector : matchLabels : app : aralez template : metadata : labels : app : aralez spec : serviceAccountName : aralez-sa containers : - name : aralez image : sadoyan/aralez:latest ports : - containerPort : 80 - containerPort : 443 volumeMounts : - name : main-config mountPath : /etc/aralez/main.yaml subPath : main.yaml readOnly : true - name : upstreams-config mountPath : /etc/aralez/config/upstreams.yml subPath : upstreams.yml readOnly : true - name : tls-certs mountPath : /etc/aralez/certs readOnly : true volumes : - name : main-config configMap : name : aralez-main-config - name : upstreams-config configMap : name : aralez-upstreams-config - name : tls-certs secret : secretName : aralez-tls Create Aralez service Example :service.yaml apiVersion : v1 kind : Service metadata : name : aralez-service spec : type : NodePort selector : app : aralez ports : - name : http port : 80 targetPort : 80 - name : https port : 443 targetPort : 443 \ud83c\udf10 Step 4: Expose Aralez with a Service Depending on how you want to reach Aralez, you can expose it in different ways. ClusterIP (internal access only): apiVersion : v1 kind : Service metadata : name : aralez namespace : default spec : selector : app : aralez ports : - port : 80 targetPort : 80 NodePort or LoadBalancer (external access): spec : type : NodePort # Use LoadBalancer if running in a cloud environment \u2705 That\u2019s it! Aralez is now running inside your Kubernetes cluster with the right permissions and is accessible through a Kubernetes Service.","title":"Kubernetes Ingress"},{"location":"assets/kubernetes/#aralez-kubernetes-integration-guide","text":"This guide walks you through setting up Aralez to run smoothly inside a Kubernetes cluster as a lightweight service mesh. We\u2019ll create the necessary ServiceAccount , apply the right RBAC roles , and then deploy Aralez as a Kubernetes Deployment with an exposed Service.","title":"\ud83d\udcc8 Aralez &amp; Kubernetes Integration Guide"},{"location":"assets/kubernetes/#step-1-create-a-service-account","text":"Aralez needs a ServiceAccount with permissions to watch Kubernetes resources like pods, endpoints, and services. You can define it in YAML: apiVersion : v1 kind : ServiceAccount metadata : name : aralez-sa","title":"\ud83d\udd11 Step 1: Create a Service Account"},{"location":"assets/kubernetes/#step-2-define-rbac-permissions","text":"Aralez requires read-only access to Kubernetes resources within a namespace. Role (scoped to a single namespace): apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : aralez-role rules : - apiGroups : [ \"\" ] resources : [ \"pods\" , \"endpoints\" , \"services\" ] verbs : [ \"get\" , \"list\" , \"watch\" ] RoleBinding (attach Role to the ServiceAccount): apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : aralez-binding subjects : - kind : ServiceAccount name : aralez-sa roleRef : kind : Role name : aralez-role apiGroup : rbac.authorization.k8s.io","title":"\ud83d\udcdc Step 2: Define RBAC Permissions"},{"location":"assets/kubernetes/#step-3-deploy-aralez","text":"Here\u2019s a minimal deployment example for running Aralez in your cluster.","title":"\ud83d\ude80 Step 3: Deploy Aralez"},{"location":"assets/kubernetes/#configs-configmap-arbitrary-configs-like-mainyaml-upstreamsyml-etc","text":"Example :main.yml threads : 12 daemon : false upstream_keepalive_pool_size : 500 pid_file : /tmp/aralez.pid error_log : /tmp/aralez_err.log upgrade_sock : /tmp/aralez.sock config_api_enabled : false config_address : 127.0.0.1:3000 proxy_address_http : 0.0.0.0:80 proxy_address_tls : 0.0.0.0:443 proxy_certificates : /etc/aralez/certs proxy_tls_grade : high upstreams_conf : /etc/aralez/config/upstreams.yml log_level : info hc_method : HEAD hc_interval : 2 master_key : 910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774 Example :upstreams.yml provider : \"kubernetes\" sticky_sessions : false to_https : false rate_limit : 100 headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" - \"Strict-Transport-Security:max-age=31536000; includeSubDomains; preload\" #authorization: # type: \"jwt\" # creds: \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\" # type: \"basic\" # creds: \"username:Passw0rd\" # type: \"apikey\" # creds: \"5ecbf799-1343-4e94-a9b5-e278af5cd313-56b45249-1839-4008-a450-a60dc76d2bae\" kubernetes : services : - hostname : \"vt-webapi-service\" path : \"/\" upstream : \"vt-webapi-service\" - hostname : \"vt-webapi-service\" upstream : \"vt-console-service\" path : \"/one\" headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 100 to_https : false - hostname : \"vt-webapi-service\" upstream : \"vt-rambulik-service\" path : \"/two\" - hostname : \"vt-websocket-service\" upstream : \"vt-websocket-service\" path : \"/\" tokenpath : \"/var/run/secrets/kubernetes.io/serviceaccount/token\" Apply config maps kubectl -n staging create configmap aralez-main-config --from-file = main.yaml = ./main.yaml kubectl -n staging create configmap aralez-upstreams-config --from-file = upstreams.yml = ./upstreams.yaml","title":"Configs \u2192 ConfigMap. Arbitrary configs like main.yaml, upstreams.yml, etc."},{"location":"assets/kubernetes/#create-certificate-and-private-key-secrets-for-tls","text":"apiVersion : v1 kind : Secret metadata : name : aralez-tls type : kubernetes.io/tls data : tls.crt : <base64-cert> tls.key : <base64-key>","title":"Create certificate and private key secrets for TLS"},{"location":"assets/kubernetes/#deployment-aralez","text":"Example :deployment.yaml apiVersion : apps/v1 kind : Deployment metadata : name : aralez spec : replicas : 1 selector : matchLabels : app : aralez template : metadata : labels : app : aralez spec : serviceAccountName : aralez-sa containers : - name : aralez image : sadoyan/aralez:latest ports : - containerPort : 80 - containerPort : 443 volumeMounts : - name : main-config mountPath : /etc/aralez/main.yaml subPath : main.yaml readOnly : true - name : upstreams-config mountPath : /etc/aralez/config/upstreams.yml subPath : upstreams.yml readOnly : true - name : tls-certs mountPath : /etc/aralez/certs readOnly : true volumes : - name : main-config configMap : name : aralez-main-config - name : upstreams-config configMap : name : aralez-upstreams-config - name : tls-certs secret : secretName : aralez-tls","title":"Deployment Aralez"},{"location":"assets/kubernetes/#create-aralez-service","text":"Example :service.yaml apiVersion : v1 kind : Service metadata : name : aralez-service spec : type : NodePort selector : app : aralez ports : - name : http port : 80 targetPort : 80 - name : https port : 443 targetPort : 443","title":"Create Aralez service"},{"location":"assets/kubernetes/#step-4-expose-aralez-with-a-service","text":"Depending on how you want to reach Aralez, you can expose it in different ways. ClusterIP (internal access only): apiVersion : v1 kind : Service metadata : name : aralez namespace : default spec : selector : app : aralez ports : - port : 80 targetPort : 80 NodePort or LoadBalancer (external access): spec : type : NodePort # Use LoadBalancer if running in a cloud environment \u2705 That\u2019s it! Aralez is now running inside your Kubernetes cluster with the right permissions and is accessible through a Kubernetes Service.","title":"\ud83c\udf10 Step 4: Expose Aralez with a Service"},{"location":"assets/metrics/","text":"\ud83d\udcc8 Aralez Prometheus Metrics Reference This document outlines Prometheus metrics for the Aralez reverse proxy. These metrics can be used for monitoring, alerting and performance analysis. Exposed to http://config_address/metrics By default http://127.0.0.1:3000/metrics \ud83d\udcca Example Grafana dashboard during stress test : \ud83d\udee0\ufe0f Prometheus Metrics 1. aralez_requests_total Type : Counter Purpose : Total amount requests served by Aralez. PromQL example: rate ( aralez_requests_total [ 5m ] ) 2. aralez_errors_total Type : Counter Purpose : Count of requests that resulted in an error. PromQL example: rate ( aralez_errors_total [ 5m ] ) 3. aralez_responses_total{status=\"200\"} Type : CounterVec Purpose : Count of responses by HTTP status code. PromQL example: rate ( aralez_responses_total { status =~ \" 5.. \"}[ 5m ] ) > 0 Useful for alerting on 5xx errors. 4. aralez_response_latency_seconds Type : Histogram Purpose : Tracks the latency of responses in seconds. Example bucket output: aralez_response_latency_seconds_bucket{le=\"0.01\"} 15 aralez_response_latency_seconds_bucket{le=\"0.1\"} 120 aralez_response_latency_seconds_bucket{le=\"0.25\"} 245 aralez_response_latency_seconds_bucket{le=\"0.5\"} 500 ... aralez_response_latency_seconds_count 1023 aralez_response_latency_seconds_sum 42.6 Metric Meaning bucket{le=\"0.1\"} 120 120 requests were \u2264 100ms bucket{le=\"0.25\"} 245 245 requests were \u2264 250ms count Total number of observations (i.e., total responses measured) sum Total time of all responses, in seconds \ud83d\udd0d How to interpret: le means \u201cless than or equal to\u201d. count is total amount of observations. sum is the total time (in seconds) of all responses. PromQL examples: \ud83d\udd39 95th percentile latency histogram_quantile ( 0.95 , rate ( aralez_response_latency_seconds_bucket [ 5m ] )) \ud83d\udd39 Average latency rate ( aralez_response_latency_seconds_sum [ 5m ] ) / rate ( aralez_response_latency_seconds_count [ 5m ] ) \u2705 Notes Metrics are registered after the first served request. \u2705 Summary of key metrics Metric Name Type What it Tells You aralez_requests_total Counter Total requests served aralez_errors_total Counter Number of failed requests aralez_responses_total{status=\"200\"} CounterVec Response status breakdown aralez_response_latency_seconds Histogram How fast responses are","title":"Prometheus Metrics"},{"location":"assets/metrics/#aralez-prometheus-metrics-reference","text":"This document outlines Prometheus metrics for the Aralez reverse proxy. These metrics can be used for monitoring, alerting and performance analysis. Exposed to http://config_address/metrics By default http://127.0.0.1:3000/metrics","title":"\ud83d\udcc8 Aralez Prometheus Metrics Reference"},{"location":"assets/metrics/#example-grafana-dashboard-during-stress-test","text":"","title":"\ud83d\udcca Example Grafana dashboard during stress test :"},{"location":"assets/metrics/#prometheus-metrics","text":"","title":"\ud83d\udee0\ufe0f Prometheus Metrics"},{"location":"assets/metrics/#1-aralez_requests_total","text":"Type : Counter Purpose : Total amount requests served by Aralez. PromQL example: rate ( aralez_requests_total [ 5m ] )","title":"1. aralez_requests_total"},{"location":"assets/metrics/#2-aralez_errors_total","text":"Type : Counter Purpose : Count of requests that resulted in an error. PromQL example: rate ( aralez_errors_total [ 5m ] )","title":"2. aralez_errors_total"},{"location":"assets/metrics/#3-aralez_responses_totalstatus200","text":"Type : CounterVec Purpose : Count of responses by HTTP status code. PromQL example: rate ( aralez_responses_total { status =~ \" 5.. \"}[ 5m ] ) > 0 Useful for alerting on 5xx errors.","title":"3. aralez_responses_total{status=\"200\"}"},{"location":"assets/metrics/#4-aralez_response_latency_seconds","text":"Type : Histogram Purpose : Tracks the latency of responses in seconds. Example bucket output: aralez_response_latency_seconds_bucket{le=\"0.01\"} 15 aralez_response_latency_seconds_bucket{le=\"0.1\"} 120 aralez_response_latency_seconds_bucket{le=\"0.25\"} 245 aralez_response_latency_seconds_bucket{le=\"0.5\"} 500 ... aralez_response_latency_seconds_count 1023 aralez_response_latency_seconds_sum 42.6 Metric Meaning bucket{le=\"0.1\"} 120 120 requests were \u2264 100ms bucket{le=\"0.25\"} 245 245 requests were \u2264 250ms count Total number of observations (i.e., total responses measured) sum Total time of all responses, in seconds","title":"4. aralez_response_latency_seconds"},{"location":"assets/metrics/#how-to-interpret","text":"le means \u201cless than or equal to\u201d. count is total amount of observations. sum is the total time (in seconds) of all responses. PromQL examples: \ud83d\udd39 95th percentile latency histogram_quantile ( 0.95 , rate ( aralez_response_latency_seconds_bucket [ 5m ] )) \ud83d\udd39 Average latency rate ( aralez_response_latency_seconds_sum [ 5m ] ) / rate ( aralez_response_latency_seconds_count [ 5m ] )","title":"\ud83d\udd0d How to interpret:"},{"location":"assets/metrics/#notes","text":"Metrics are registered after the first served request. \u2705 Summary of key metrics Metric Name Type What it Tells You aralez_requests_total Counter Total requests served aralez_errors_total Counter Number of failed requests aralez_responses_total{status=\"200\"} CounterVec Response status breakdown aralez_response_latency_seconds Histogram How fast responses are","title":"\u2705 Notes"},{"location":"assets/perf/","text":"\ud83d\ude80 Aralez performance benchmarks \ud83d\udca1 Simple benchmark by Oha Reverse Proxy Mixed Load Benchmark Test Overview Proxies tested: Aralez HAProxy Envoy NginX Traefik Caddy Load profile: Proxy servers running on same host with different ports 2x Oha instances for parallel testing of GET/POST requests 3x Upstream servers on separate machines with responses per 3 domains with sample json files Tuned Kernel parameters for heavy load 10 gbit network All instances running 4 Core+HT Intel(R) Xeon(R) CPU E5-2699C v4 @ 2.20GHz 60 URLs (deep / nested paths) Majority HTTPS (TLS termination active) Mixed GET + POST JSON payload for POST 2048 total concurrent connections (2 \u00d7 1024) Upstreams on separate machines No caching Mixed routing and domain handling Latency Distribution (Percentiles) All values in seconds unless otherwise specified. GET Requests Percentile Aralez HAProxy Envoy NGINX Traefik Caddy p10 0.0024 0.0303 0.0307 0.0022 0.0781 0.0749 p25 0.0038 0.0492 0.0467 0.0025 0.1105 0.1105 p50 0.0061 0.0691 0.0640 0.0029 0.1271 0.1574 p75 0.0088 0.1035 0.0943 0.0054 0.1483 0.2487 p90 0.0132 0.1407 0.1432 0.0263 0.1798 0.3919 p95 0.0228 0.1742 0.2263 0.0700 0.2142 0.4960 p99 0.0528 0.2846 0.4744 0.1292 0.3859 0.7093 p99.9 0.1931 0.5404 1.0309 0.2525 0.7853 1.0799 p99.99 0.4220 2.5017 2.1869 0.4524 1.1503 2.2552 POST Requests Percentile Aralez HAProxy Envoy NGINX Traefik Caddy p10 0.0024 0.0295 0.0376 0.0215 0.0790 0.0754 p25 0.0038 0.0485 0.0625 0.0246 0.1107 0.1110 p50 0.0061 0.0684 0.0973 0.0288 0.1273 0.1579 p75 0.0088 0.1027 0.1543 0.0500 0.1484 0.2494 p90 0.0134 0.1399 0.3758 0.2605 0.1801 0.3838 p95 0.0250 0.1730 0.5454 0.4959 0.2147 0.4866 p99 0.0507 0.2829 1.2614 1.2734 0.3741 0.6944 p99.9 0.1141 0.5353 2.5964 2.3265 0.6698 1.0126 p99.99 0.3616 1.4382 4.0073 4.1945 1.2958 1.3822 Observations Median Latency (p50) Aralez shows extremely low median latency in both GET and POST. HAProxy and Envoy follow closely for GET. NGINX performs well in POST median. Traefik and Caddy have noticeably higher baseline latency. Tail Latency (p99) GET Best: Aralez (0.0528s) Next: NGINX (0.1292s) HAProxy and Traefik moderate Envoy higher tail Caddy highest tail POST Best: Aralez (0.0507s) HAProxy stable Traefik acceptable Envoy and NGINX show significant tail increase under POST Caddy moderate but above HAProxy Extreme Tail (p99.9 / p99.99) Aralez remains very stable even at extreme percentiles. HAProxy scales predictably but tail widens at 99.99. Envoy and NGINX show heavy tail amplification under POST. Traefik moderate. Caddy shows noticeable spread under stress. High-Level Summary Aralez Best p99 for both GET and POST Extremely tight latency distribution Minimal tail amplification HAProxy Very consistent Predictable scaling Strong under mixed workload NginX Good GET stability POST tail increases under high concurrency Envoy Good median Heavy tail under POST Likely requires tuning for buffer/thread settings Traefik Higher baseline Stable but not high-performance edge grade Caddy Clean configuration Higher baseline latency Larger tail spread under load Requests per second chart during test \ud83d\udcc8 Throughput Stability & Peak RPS Analysis This chart illustrates the Requests Per Second (RPS) during sequential stress tests under a 1024-concurrency load. Each color block represents the \"steady-state\" performance of the proxy after the kernel was fully optimized. Aralez: Dominates the chart with the highest sustained throughput, reaching a clean plateau near 30K RPS. Its \"flat-top\" signature indicates perfect synchronization with the tuned TCP stack, showing almost zero throughput jitter. Nginx: Achieves high throughput but exhibits significant \"noise\" and variance (jagged peaks) compared to the stability of Aralez. HAProxy: Showcases its trademark \"unshakeable\" stability with perfectly flat lines, though it operates at a lower throughput ceiling (~17K RPS) in this specific environment. Envoy, Traefik, & Caddy: These engines show a visible \"performance tax,\" with lower sustained RPS and more frequent throughput dips, highlighting the efficiency of the Aralez event-loop. \ud83d\ude80 High-Performance Proxy Benchmark Report \ud83e\udd47 Aralez Performance Highlights: Tail Latency Dominance : Aralez achieves a p99 of 0.1931 10 sec , outperforming Nginx ( 0.2525 10 sec ) by more than 2x . Zero Payload Penalty : Unlike Envoy or Nginx, Aralez shows almost identical performance between GET and POST requests, proving its efficient buffer management. Median Stability : A p50 of 0.0088 10 sec ensures that the vast majority of users experience near-instant response times. \ud83d\udcca Detailed Comparison Tables 1. Response Time Histogram Threshold ARALEZ GET ARALEZ POST HAPROXY GET HAPROXY POST ENVOY GET ENVOY POST NGINX GET NGINX POST TRAEFIK GET TRAEFIK POST CADDY GET CADDY POST 0.000 10 sec 1 1 1 1 1 1 1 1 1 1 1 1 0.167 10 sec 3691654 3742220 3700723 3649573 3502620 1735719 2589172 2658901 2245581 2253228 1381444 1509978 0.333 10 sec 3537 2142 18484 116056 23162 70454 2946 105969 18185 16159 126442 17428 0.500 10 sec 756 372 1096 5880 2442 16369 195 14068 2069 1110 7700 144 0.666 10 sec 8 6 149 1070 805 6437 7 1948 72 326 253 4 0.832 10 sec 129 24 14 528 303 2572 8 1543 21 94 78 6 0.999 10 sec 28 9 104 280 106 898 0 291 75 30 124 8 1.165 10 sec 2 0 169 254 38 488 0 102 0 0 41 0 1.332 10 sec 0 1 266 147 42 238 0 98 0 0 15 0 1.498 10 sec 3 0 179 190 14 62 0 16 1 1 10 0 1.665 10 sec 30 3 130 78 17 51 1 11 2 2 2 1 2. Response Time Distribution Percentile ARALEZ GET ARALEZ POST HAPROXY GET HAPROXY POST ENVOY GET ENVOY POST NGINX GET NGINX POST TRAEFIK GET TRAEFIK POST CADDY GET CADDY POST 10% 0.0038 10 sec 0.0038 10 sec 0.0492 sec 0.0485 sec 0.0467 sec 0.0625 sec 0.0025 10 sec 0.0246 sec 0.1105 sec 0.1107 sec 0.1105 sec 0.1110 sec 25% 0.0061 10 sec 0.0061 10 sec 0.0691 sec 0.0684 sec 0.0640 sec 0.0973 sec 0.0029 10 sec 0.0288 sec 0.1271 sec 0.1273 sec 0.1574 sec 0.1579 sec 50% 0.0088 10 sec 0.0088 10 sec 0.1035 sec 0.1027 sec 0.0943 sec 0.1543 sec 0.0054 10 sec 0.0500 sec 0.1483 sec 0.1484 sec 0.2487 sec 0.2494 sec 75% 0.0132 10 sec 0.0134 10 sec 0.1407 sec 0.1399 sec 0.1432 sec 0.3758 sec 0.0263 10 sec 0.2605 sec 0.1798 sec 0.1801 sec 0.3919 sec 0.3838 sec 90% 0.0228 10 sec 0.0250 10 sec 0.1742 sec 0.1730 sec 0.2263 sec 0.5454 sec 0.0700 10 sec 0.4959 sec 0.2142 sec 0.2147 sec 0.4960 sec 0.4866 sec 95% 0.0528 10 sec 0.0507 10 sec 0.2846 sec 0.2829 sec 0.4744 sec 1.2614 sec 0.1292 10 sec 1.2734 sec 0.3859 sec 0.3741 sec 0.7093 sec 0.6944 sec 99% 0.1931 10 sec 0.1141 10 sec 0.5404 sec 0.5353 sec 1.0309 sec 2.5964 sec 0.2525 10 sec 2.3265 sec 0.7853 sec 0.6698 sec 1.0799 sec 1.0126 sec 99.9% 0.4220 10 sec 0.3616 10 sec 2.5017 sec 1.4382 sec 2.1869 sec 4.0073 sec 0.4524 10 sec 4.1945 sec 1.1503 sec 1.2958 sec 2.2552 sec 1.3822 sec \ud83c\udfc6 Why Aralez is the New Standard Aralez isn't just fast; it's predictably fast . Under extreme load (2x1024 concurrency), most proxies start \"stuttering,\" but Aralez maintains a rock-solid performance profile.","title":"Benchmarks"},{"location":"assets/perf/#aralez-performance-benchmarks","text":"","title":"\ud83d\ude80 Aralez performance benchmarks"},{"location":"assets/perf/#simple-benchmark-by-oha","text":"","title":"\ud83d\udca1 Simple benchmark by Oha"},{"location":"assets/perf/#reverse-proxy-mixed-load-benchmark","text":"","title":"Reverse Proxy Mixed Load Benchmark"},{"location":"assets/perf/#test-overview","text":"Proxies tested: Aralez HAProxy Envoy NginX Traefik Caddy Load profile: Proxy servers running on same host with different ports 2x Oha instances for parallel testing of GET/POST requests 3x Upstream servers on separate machines with responses per 3 domains with sample json files Tuned Kernel parameters for heavy load 10 gbit network All instances running 4 Core+HT Intel(R) Xeon(R) CPU E5-2699C v4 @ 2.20GHz 60 URLs (deep / nested paths) Majority HTTPS (TLS termination active) Mixed GET + POST JSON payload for POST 2048 total concurrent connections (2 \u00d7 1024) Upstreams on separate machines No caching Mixed routing and domain handling","title":"Test Overview"},{"location":"assets/perf/#latency-distribution-percentiles","text":"All values in seconds unless otherwise specified. GET Requests Percentile Aralez HAProxy Envoy NGINX Traefik Caddy p10 0.0024 0.0303 0.0307 0.0022 0.0781 0.0749 p25 0.0038 0.0492 0.0467 0.0025 0.1105 0.1105 p50 0.0061 0.0691 0.0640 0.0029 0.1271 0.1574 p75 0.0088 0.1035 0.0943 0.0054 0.1483 0.2487 p90 0.0132 0.1407 0.1432 0.0263 0.1798 0.3919 p95 0.0228 0.1742 0.2263 0.0700 0.2142 0.4960 p99 0.0528 0.2846 0.4744 0.1292 0.3859 0.7093 p99.9 0.1931 0.5404 1.0309 0.2525 0.7853 1.0799 p99.99 0.4220 2.5017 2.1869 0.4524 1.1503 2.2552 POST Requests Percentile Aralez HAProxy Envoy NGINX Traefik Caddy p10 0.0024 0.0295 0.0376 0.0215 0.0790 0.0754 p25 0.0038 0.0485 0.0625 0.0246 0.1107 0.1110 p50 0.0061 0.0684 0.0973 0.0288 0.1273 0.1579 p75 0.0088 0.1027 0.1543 0.0500 0.1484 0.2494 p90 0.0134 0.1399 0.3758 0.2605 0.1801 0.3838 p95 0.0250 0.1730 0.5454 0.4959 0.2147 0.4866 p99 0.0507 0.2829 1.2614 1.2734 0.3741 0.6944 p99.9 0.1141 0.5353 2.5964 2.3265 0.6698 1.0126 p99.99 0.3616 1.4382 4.0073 4.1945 1.2958 1.3822","title":"Latency Distribution (Percentiles)"},{"location":"assets/perf/#observations","text":"Median Latency (p50) Aralez shows extremely low median latency in both GET and POST. HAProxy and Envoy follow closely for GET. NGINX performs well in POST median. Traefik and Caddy have noticeably higher baseline latency.","title":"Observations"},{"location":"assets/perf/#tail-latency-p99","text":"GET Best: Aralez (0.0528s) Next: NGINX (0.1292s) HAProxy and Traefik moderate Envoy higher tail Caddy highest tail POST Best: Aralez (0.0507s) HAProxy stable Traefik acceptable Envoy and NGINX show significant tail increase under POST Caddy moderate but above HAProxy","title":"Tail Latency (p99)"},{"location":"assets/perf/#extreme-tail-p999-p9999","text":"Aralez remains very stable even at extreme percentiles. HAProxy scales predictably but tail widens at 99.99. Envoy and NGINX show heavy tail amplification under POST. Traefik moderate. Caddy shows noticeable spread under stress.","title":"Extreme Tail (p99.9 / p99.99)"},{"location":"assets/perf/#high-level-summary","text":"Aralez Best p99 for both GET and POST Extremely tight latency distribution Minimal tail amplification HAProxy Very consistent Predictable scaling Strong under mixed workload NginX Good GET stability POST tail increases under high concurrency Envoy Good median Heavy tail under POST Likely requires tuning for buffer/thread settings Traefik Higher baseline Stable but not high-performance edge grade Caddy Clean configuration Higher baseline latency Larger tail spread under load","title":"High-Level Summary"},{"location":"assets/perf/#requests-per-second-chart-during-test","text":"","title":"Requests per second chart during test"},{"location":"assets/perf/#throughput-stability-peak-rps-analysis","text":"This chart illustrates the Requests Per Second (RPS) during sequential stress tests under a 1024-concurrency load. Each color block represents the \"steady-state\" performance of the proxy after the kernel was fully optimized. Aralez: Dominates the chart with the highest sustained throughput, reaching a clean plateau near 30K RPS. Its \"flat-top\" signature indicates perfect synchronization with the tuned TCP stack, showing almost zero throughput jitter. Nginx: Achieves high throughput but exhibits significant \"noise\" and variance (jagged peaks) compared to the stability of Aralez. HAProxy: Showcases its trademark \"unshakeable\" stability with perfectly flat lines, though it operates at a lower throughput ceiling (~17K RPS) in this specific environment. Envoy, Traefik, & Caddy: These engines show a visible \"performance tax,\" with lower sustained RPS and more frequent throughput dips, highlighting the efficiency of the Aralez event-loop.","title":"\ud83d\udcc8 Throughput Stability &amp; Peak RPS Analysis"},{"location":"assets/perf/#high-performance-proxy-benchmark-report","text":"","title":"\ud83d\ude80 High-Performance Proxy Benchmark Report"},{"location":"assets/perf/#aralez-performance-highlights","text":"Tail Latency Dominance : Aralez achieves a p99 of 0.1931 10 sec , outperforming Nginx ( 0.2525 10 sec ) by more than 2x . Zero Payload Penalty : Unlike Envoy or Nginx, Aralez shows almost identical performance between GET and POST requests, proving its efficient buffer management. Median Stability : A p50 of 0.0088 10 sec ensures that the vast majority of users experience near-instant response times.","title":"\ud83e\udd47 Aralez Performance Highlights:"},{"location":"assets/perf/#detailed-comparison-tables","text":"","title":"\ud83d\udcca Detailed Comparison Tables"},{"location":"assets/perf/#1-response-time-histogram","text":"Threshold ARALEZ GET ARALEZ POST HAPROXY GET HAPROXY POST ENVOY GET ENVOY POST NGINX GET NGINX POST TRAEFIK GET TRAEFIK POST CADDY GET CADDY POST 0.000 10 sec 1 1 1 1 1 1 1 1 1 1 1 1 0.167 10 sec 3691654 3742220 3700723 3649573 3502620 1735719 2589172 2658901 2245581 2253228 1381444 1509978 0.333 10 sec 3537 2142 18484 116056 23162 70454 2946 105969 18185 16159 126442 17428 0.500 10 sec 756 372 1096 5880 2442 16369 195 14068 2069 1110 7700 144 0.666 10 sec 8 6 149 1070 805 6437 7 1948 72 326 253 4 0.832 10 sec 129 24 14 528 303 2572 8 1543 21 94 78 6 0.999 10 sec 28 9 104 280 106 898 0 291 75 30 124 8 1.165 10 sec 2 0 169 254 38 488 0 102 0 0 41 0 1.332 10 sec 0 1 266 147 42 238 0 98 0 0 15 0 1.498 10 sec 3 0 179 190 14 62 0 16 1 1 10 0 1.665 10 sec 30 3 130 78 17 51 1 11 2 2 2 1","title":"1. Response Time Histogram"},{"location":"assets/perf/#2-response-time-distribution","text":"Percentile ARALEZ GET ARALEZ POST HAPROXY GET HAPROXY POST ENVOY GET ENVOY POST NGINX GET NGINX POST TRAEFIK GET TRAEFIK POST CADDY GET CADDY POST 10% 0.0038 10 sec 0.0038 10 sec 0.0492 sec 0.0485 sec 0.0467 sec 0.0625 sec 0.0025 10 sec 0.0246 sec 0.1105 sec 0.1107 sec 0.1105 sec 0.1110 sec 25% 0.0061 10 sec 0.0061 10 sec 0.0691 sec 0.0684 sec 0.0640 sec 0.0973 sec 0.0029 10 sec 0.0288 sec 0.1271 sec 0.1273 sec 0.1574 sec 0.1579 sec 50% 0.0088 10 sec 0.0088 10 sec 0.1035 sec 0.1027 sec 0.0943 sec 0.1543 sec 0.0054 10 sec 0.0500 sec 0.1483 sec 0.1484 sec 0.2487 sec 0.2494 sec 75% 0.0132 10 sec 0.0134 10 sec 0.1407 sec 0.1399 sec 0.1432 sec 0.3758 sec 0.0263 10 sec 0.2605 sec 0.1798 sec 0.1801 sec 0.3919 sec 0.3838 sec 90% 0.0228 10 sec 0.0250 10 sec 0.1742 sec 0.1730 sec 0.2263 sec 0.5454 sec 0.0700 10 sec 0.4959 sec 0.2142 sec 0.2147 sec 0.4960 sec 0.4866 sec 95% 0.0528 10 sec 0.0507 10 sec 0.2846 sec 0.2829 sec 0.4744 sec 1.2614 sec 0.1292 10 sec 1.2734 sec 0.3859 sec 0.3741 sec 0.7093 sec 0.6944 sec 99% 0.1931 10 sec 0.1141 10 sec 0.5404 sec 0.5353 sec 1.0309 sec 2.5964 sec 0.2525 10 sec 2.3265 sec 0.7853 sec 0.6698 sec 1.0799 sec 1.0126 sec 99.9% 0.4220 10 sec 0.3616 10 sec 2.5017 sec 1.4382 sec 2.1869 sec 4.0073 sec 0.4524 10 sec 4.1945 sec 1.1503 sec 1.2958 sec 2.2552 sec 1.3822 sec","title":"2. Response Time Distribution"},{"location":"assets/perf/#why-aralez-is-the-new-standard","text":"Aralez isn't just fast; it's predictably fast . Under extreme load (2x1024 concurrency), most proxies start \"stuttering,\" but Aralez maintains a rock-solid performance profile.","title":"\ud83c\udfc6 Why Aralez is the New Standard"},{"location":"assets/quickstart/","text":"\ud83d\ude80 Quick Start Run it manually: Download the prebuilt binary for your architecture from releases section of GitHub repo Make the binary executable chmod 755 ./aralez-VERSION and run. File names: File Name Description aralez-x86_64-musl.gz Static Linux x86_64 binary, without any system dependency aralez-x86_64-glibc.gz Dynamic Linux x86_64 binary, with minimal system dependencies aralez-aarch64-musl.gz Static Linux ARM64 binary, without any system dependency aralez-aarch64-glibc.gz Dynamic Linux ARM64 binary, with minimal system dependencies sadoyan/aralez Docker image on Debian 13 slim (https://hub.docker.com/r/sadoyan/aralez) Download the latest release for your architecture from Releases . shell wget https://github.com/sadoyan/aralez/releases/download/vX.Y.Z/aralez-xxx-yyy.tar.gz tar -xzf aralez-xxx-yyy.tar.gz Make it executable chmod +x aralez-xxx-yyy Copy example configuration and adjust to your needs: wget https://raw.githubusercontent.com/sadoyan/aralez/refs/heads/main/etc/main.yaml wget https://raw.githubusercontent.com/sadoyan/aralez/refs/heads/main/etc/upstreams.yaml Edit to match your needs Run it aralez-xxx-yyy -c main.yaml Or via docker docker run -d \\ -v /local/path/to/config:/etc/aralez:ro \\ -p 80 :80 \\ -p 443 :443 \\ sadoyan/aralez","title":"Quick Start"},{"location":"assets/quickstart/#quick-start","text":"","title":"\ud83d\ude80 Quick Start"},{"location":"assets/quickstart/#run-it-manually","text":"Download the prebuilt binary for your architecture from releases section of GitHub repo Make the binary executable chmod 755 ./aralez-VERSION and run. File names: File Name Description aralez-x86_64-musl.gz Static Linux x86_64 binary, without any system dependency aralez-x86_64-glibc.gz Dynamic Linux x86_64 binary, with minimal system dependencies aralez-aarch64-musl.gz Static Linux ARM64 binary, without any system dependency aralez-aarch64-glibc.gz Dynamic Linux ARM64 binary, with minimal system dependencies sadoyan/aralez Docker image on Debian 13 slim (https://hub.docker.com/r/sadoyan/aralez) Download the latest release for your architecture from Releases . shell wget https://github.com/sadoyan/aralez/releases/download/vX.Y.Z/aralez-xxx-yyy.tar.gz tar -xzf aralez-xxx-yyy.tar.gz Make it executable chmod +x aralez-xxx-yyy Copy example configuration and adjust to your needs: wget https://raw.githubusercontent.com/sadoyan/aralez/refs/heads/main/etc/main.yaml wget https://raw.githubusercontent.com/sadoyan/aralez/refs/heads/main/etc/upstreams.yaml Edit to match your needs Run it aralez-xxx-yyy -c main.yaml","title":"Run it manually:"},{"location":"assets/quickstart/#or-via-docker","text":"docker run -d \\ -v /local/path/to/config:/etc/aralez:ro \\ -p 80 :80 \\ -p 443 :443 \\ sadoyan/aralez","title":"Or via docker"}]}