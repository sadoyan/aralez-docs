{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Aralez (\u0531\u0580\u0561\u056c\u0565\u0566), Reverse proxy and service mesh built on top of Cloudflare's Pingora What Aralez means ? Aralez = \u0531\u0580\u0561\u056c\u0565\u0566 .Named after the legendary Armenian guardian spirit, winged dog-like creature, that descend upon fallen heroes to lick their wounds and resurrect them. . Built on Rust, on top of Cloudflare\u2019s Pingora engine , Aralez delivers world-class performance, security and scalability \u2014 right out of the box. Support my OpenSource initiative : \ud83d\udd27 Key Features Dynamic Config Reloads \u2014 Upstreams can be updated live via API, no restart required. TLS Termination \u2014 Built-in OpenSSL support. Automatic load of certificates \u2014 Automatically reads and loads certificates from a folder, without a restart. Upstreams TLS detection \u2014 Aralez will automatically detect if upstreams uses secure connection. Built in rate limiter \u2014 Limit requests to server, by setting up upper limit for requests per seconds, per virtualhost. Global rate limiter \u2014 Set rate limit for all virtualhosts. Per path rate limiter \u2014 Set rate limit for specific paths. Path limits will override global limits. Authentication \u2014 Supports Basic Auth, API tokens, and JWT verification. Basic Auth API Key via x-api-key header JWT Auth , with tokens issued by Aralez itself via /jwt API \u2b07\ufe0f See below for examples and implementation details. Load Balancing Strategies Round-robin Failover with health checks Sticky sessions via cookies Unified Port \u2014 Serve HTTP and WebSocket traffic over the same connection. Built in file server \u2014 Build in minimalistic file server for serving static files, should be added as upstreams for public access. Memory Safe \u2014 Created purely on Rust. High Performance \u2014 Built with Pingora and tokio for async I/O. \ud83c\udf0d Highlights \u2699\ufe0f Upstream Providers: file Upstreams are declared in config file. consul Upstreams are dynamically updated from Hashicorp Consul. \ud83d\udd01 Hot Reloading: Modify upstreams on the fly via upstreams.yaml \u2014 no restart needed. \ud83d\udd2e Automatic WebSocket Support: Zero config \u2014 connection upgrades are handled seamlessly. \ud83d\udd2e Automatic GRPC Support: Zero config, Requires ssl to proxy, gRPC handled seamlessly. \ud83d\udd2e Upstreams Session Stickiness: Enable/Disable Sticky sessions globally. \ud83d\udd10 TLS Termination: Fully supports TLS for upstreams and downstreams. \ud83d\udee1\ufe0f Built-in Authentication Basic Auth, JWT, API key. \ud83e\udde0 Header Injection: Global and per-route header configuration. \ud83e\uddea Health Checks: Pluggable health check methods for upstreams. \ud83d\udef0\ufe0f Remote Config Push: Lightweight HTTP API to update configs from CI/CD or other systems. \ud83d\udcc1 File Structure . \u251c\u2500\u2500 main . yaml # Main configuration loaded at startup \u251c\u2500\u2500 upstreams . yaml # Watched config with upstream mappings \u251c\u2500\u2500 etc / \u2502 \u251c\u2500\u2500 server . crt # TLS certificate (required if using TLS) \u2502 \u2514\u2500\u2500 key . pem # TLS private key \ud83d\udee0 Configuration Overview \ud83d\udd27 main.yaml Key Example Value Description threads 12 Number of running daemon threads. Optional, defaults to 1 user aralez Optional, Username for running aralez after dropping root privileges, requires to launch as root group aralez Optional,Group for running aralez after dropping root privileges, requires to launch as root daemon false Run in background (boolean) upstream_keepalive_pool_size 500 Pool size for upstream keepalive connections pid_file /tmp/aralez.pid Path to PID file error_log /tmp/aralez_err.log Path to error log file upgrade_sock /tmp/aralez.sock Path to live upgrade socket file config_address 0.0.0.0:3000 HTTP API address for pushing upstreams.yaml from remote location config_tls_address 0.0.0.0:3001 HTTPS API address for pushing upstreams.yaml from remote location config_tls_certificate etc/server.crt Certificate file path for API. Mandatory if proxy_address_tls is set, else optional proxy_tls_grade (high, medium, unsafe) Grade of TLS ciphers, for easy configuration. High matches Qualys SSL Labs A+ (defaults to medium) config_tls_key_file etc/key.pem Private Key file path. Mandatory if proxy_address_tls is set, else optional proxy_address_http 0.0.0.0:6193 Aralez HTTP bind address proxy_address_tls 0.0.0.0:6194 Aralez HTTPS bind address (Optional) proxy_certificates etc/certs/ The directory containing certificate and key files. In a format {NAME}.crt, {NAME}.key. upstreams_conf etc/upstreams.yaml The location of upstreams file log_level info Log level , possible values : info, warn, error, debug, trace, off hc_method HEAD Healthcheck method (HEAD, GET, POST are supported) UPPERCASE hc_interval 2 Interval for health checks in seconds master_key 5aeff7f9-7b94-447c-af60-e8c488544a3e Master key for working with API server and JWT Secret generation file_server_folder /some/local/folder Optional, local folder to serve file_server_address 127.0.0.1:3002 Optional, Local address for file server. Can set as upstream for public access config_api_enabled true Boolean to enable/disable remote config push capability \ud83c\udf10 upstreams.yaml provider : file or consul File-based upstreams define: Hostnames and routing paths Backend servers (load-balanced) Optional request headers, specific to this upstream Global headers (e.g., CORS) apply to all proxied responses Optional authentication (Basic, API Key, JWT) \ud83d\udee0 Installation Download the prebuilt binary for your architecture from releases section of GitHub repo Make the binary executable chmod 755 ./aralez-VERSION and run. File names: File Name Description aralez-x86_64-musl.gz Static Linux x86_64 binary, without any system dependency aralez-x86_64-glibc.gz Dynamic Linux x86_64 binary, with minimal system dependencies aralez-aarch64-musl.gz Static Linux ARM64 binary, without any system dependency aralez-aarch64-glibc.gz Dynamic Linux ARM64 binary, with minimal system dependencies sadoyan/aralez Docker image on Debian 13 slim (https://hub.docker.com/r/sadoyan/aralez) Via docker docker run -d \\ -v /local/path/to/config:/etc/aralez:ro \\ -p 80 :80 \\ -p 443 :443 \\ sadoyan/aralez \ud83d\udd04 Hot Reload Changes to upstreams.yaml are applied immediately. No need to restart the proxy \u2014 just save the file. If consul provider is chosen, upstreams will be periodically update from Consul's API. \ud83d\udd10 TLS Support To enable TLS for A proxy server: Currently only OpenSSL is supported, working on Boringssl and Rustls Set proxy_address_tls in main.yaml Provide tls_certificate and tls_key_file \ud83d\udce1 Remote Config API Push new upstreams.yaml over HTTP to config_address ( :3000 by default). Useful for CI/CD automation or remote config updates. URL parameter. key=MASTERKEY is required. MASTERKEY is the value of master_key in the main.yaml curl -XPOST --data-binary @./etc/upstreams.txt 127 .0.0.1:3000/conf?key = ${ MASTERKEY } \ud83d\udcc3 License Apache License Version 2.0 \ud83e\udde0 Notes Uses Pingora under the hood for efficiency and flexibility. Designed for edge proxying, internal routing, or hybrid cloud scenarios. Transparent, fully automatic WebSocket upgrade support. Transparent, fully automatic gRPC proxy. Sticky session support. HTTP2 ready. \ud83d\udcca Why Choose Aralez? \u2013 Feature Comparison Feature Aralez Nginx HAProxy Traefik Hot Reload \u2705 Yes (live, API/file) \u26a0\ufe0f Reloads config \u26a0\ufe0f Reloads config \u2705 Yes (dynamic) JWT Auth \u2705 Built-in \u274c External scripts \u274c External Lua or agent \u26a0\ufe0f With plugins WebSocket Support \u2705 Automatic \u26a0\ufe0f Manual config \u2705 Yes \u2705 Yes gRPC Support \u2705 Automatic (no config) \u26a0\ufe0f Manual + HTTP/2 + TLS \u26a0\ufe0f Complex setup \u2705 Native TLS Termination \u2705 Built-in (OpenSSL) \u2705 Yes \u2705 Yes \u2705 Yes TLS Upstream Detection \u2705 Automatic \u274c \u274c \u274c HTTP/2 Support \u2705 Automatic \u26a0\ufe0f Requires extra config \u26a0\ufe0f Requires build flags \u2705 Native Sticky Sessions \u2705 Cookie-based \u26a0\ufe0f In plus version only \u2705 \u2705 Prometheus Metrics \u2705 Built in \u26a0\ufe0f With Lua or exporter \u26a0\ufe0f With external script \u2705 Native Built With \ud83e\udd80 Rust C C Go","title":"Home"},{"location":"#aralez-reverse-proxy-and-service-mesh-built-on-top-of-cloudflares-pingora","text":"What Aralez means ? Aralez = \u0531\u0580\u0561\u056c\u0565\u0566 .Named after the legendary Armenian guardian spirit, winged dog-like creature, that descend upon fallen heroes to lick their wounds and resurrect them. . Built on Rust, on top of Cloudflare\u2019s Pingora engine , Aralez delivers world-class performance, security and scalability \u2014 right out of the box. Support my OpenSource initiative :","title":"Aralez (\u0531\u0580\u0561\u056c\u0565\u0566), Reverse proxy and service mesh built on top of Cloudflare's Pingora"},{"location":"#key-features","text":"Dynamic Config Reloads \u2014 Upstreams can be updated live via API, no restart required. TLS Termination \u2014 Built-in OpenSSL support. Automatic load of certificates \u2014 Automatically reads and loads certificates from a folder, without a restart. Upstreams TLS detection \u2014 Aralez will automatically detect if upstreams uses secure connection. Built in rate limiter \u2014 Limit requests to server, by setting up upper limit for requests per seconds, per virtualhost. Global rate limiter \u2014 Set rate limit for all virtualhosts. Per path rate limiter \u2014 Set rate limit for specific paths. Path limits will override global limits. Authentication \u2014 Supports Basic Auth, API tokens, and JWT verification. Basic Auth API Key via x-api-key header JWT Auth , with tokens issued by Aralez itself via /jwt API \u2b07\ufe0f See below for examples and implementation details. Load Balancing Strategies Round-robin Failover with health checks Sticky sessions via cookies Unified Port \u2014 Serve HTTP and WebSocket traffic over the same connection. Built in file server \u2014 Build in minimalistic file server for serving static files, should be added as upstreams for public access. Memory Safe \u2014 Created purely on Rust. High Performance \u2014 Built with Pingora and tokio for async I/O.","title":"\ud83d\udd27 Key Features"},{"location":"#highlights","text":"\u2699\ufe0f Upstream Providers: file Upstreams are declared in config file. consul Upstreams are dynamically updated from Hashicorp Consul. \ud83d\udd01 Hot Reloading: Modify upstreams on the fly via upstreams.yaml \u2014 no restart needed. \ud83d\udd2e Automatic WebSocket Support: Zero config \u2014 connection upgrades are handled seamlessly. \ud83d\udd2e Automatic GRPC Support: Zero config, Requires ssl to proxy, gRPC handled seamlessly. \ud83d\udd2e Upstreams Session Stickiness: Enable/Disable Sticky sessions globally. \ud83d\udd10 TLS Termination: Fully supports TLS for upstreams and downstreams. \ud83d\udee1\ufe0f Built-in Authentication Basic Auth, JWT, API key. \ud83e\udde0 Header Injection: Global and per-route header configuration. \ud83e\uddea Health Checks: Pluggable health check methods for upstreams. \ud83d\udef0\ufe0f Remote Config Push: Lightweight HTTP API to update configs from CI/CD or other systems.","title":"\ud83c\udf0d Highlights"},{"location":"#file-structure","text":". \u251c\u2500\u2500 main . yaml # Main configuration loaded at startup \u251c\u2500\u2500 upstreams . yaml # Watched config with upstream mappings \u251c\u2500\u2500 etc / \u2502 \u251c\u2500\u2500 server . crt # TLS certificate (required if using TLS) \u2502 \u2514\u2500\u2500 key . pem # TLS private key","title":"\ud83d\udcc1 File Structure"},{"location":"#configuration-overview","text":"","title":"\ud83d\udee0 Configuration Overview"},{"location":"#mainyaml","text":"Key Example Value Description threads 12 Number of running daemon threads. Optional, defaults to 1 user aralez Optional, Username for running aralez after dropping root privileges, requires to launch as root group aralez Optional,Group for running aralez after dropping root privileges, requires to launch as root daemon false Run in background (boolean) upstream_keepalive_pool_size 500 Pool size for upstream keepalive connections pid_file /tmp/aralez.pid Path to PID file error_log /tmp/aralez_err.log Path to error log file upgrade_sock /tmp/aralez.sock Path to live upgrade socket file config_address 0.0.0.0:3000 HTTP API address for pushing upstreams.yaml from remote location config_tls_address 0.0.0.0:3001 HTTPS API address for pushing upstreams.yaml from remote location config_tls_certificate etc/server.crt Certificate file path for API. Mandatory if proxy_address_tls is set, else optional proxy_tls_grade (high, medium, unsafe) Grade of TLS ciphers, for easy configuration. High matches Qualys SSL Labs A+ (defaults to medium) config_tls_key_file etc/key.pem Private Key file path. Mandatory if proxy_address_tls is set, else optional proxy_address_http 0.0.0.0:6193 Aralez HTTP bind address proxy_address_tls 0.0.0.0:6194 Aralez HTTPS bind address (Optional) proxy_certificates etc/certs/ The directory containing certificate and key files. In a format {NAME}.crt, {NAME}.key. upstreams_conf etc/upstreams.yaml The location of upstreams file log_level info Log level , possible values : info, warn, error, debug, trace, off hc_method HEAD Healthcheck method (HEAD, GET, POST are supported) UPPERCASE hc_interval 2 Interval for health checks in seconds master_key 5aeff7f9-7b94-447c-af60-e8c488544a3e Master key for working with API server and JWT Secret generation file_server_folder /some/local/folder Optional, local folder to serve file_server_address 127.0.0.1:3002 Optional, Local address for file server. Can set as upstream for public access config_api_enabled true Boolean to enable/disable remote config push capability","title":"\ud83d\udd27 main.yaml"},{"location":"#upstreamsyaml","text":"provider : file or consul File-based upstreams define: Hostnames and routing paths Backend servers (load-balanced) Optional request headers, specific to this upstream Global headers (e.g., CORS) apply to all proxied responses Optional authentication (Basic, API Key, JWT)","title":"\ud83c\udf10 upstreams.yaml"},{"location":"#installation","text":"Download the prebuilt binary for your architecture from releases section of GitHub repo Make the binary executable chmod 755 ./aralez-VERSION and run. File names: File Name Description aralez-x86_64-musl.gz Static Linux x86_64 binary, without any system dependency aralez-x86_64-glibc.gz Dynamic Linux x86_64 binary, with minimal system dependencies aralez-aarch64-musl.gz Static Linux ARM64 binary, without any system dependency aralez-aarch64-glibc.gz Dynamic Linux ARM64 binary, with minimal system dependencies sadoyan/aralez Docker image on Debian 13 slim (https://hub.docker.com/r/sadoyan/aralez) Via docker docker run -d \\ -v /local/path/to/config:/etc/aralez:ro \\ -p 80 :80 \\ -p 443 :443 \\ sadoyan/aralez","title":"\ud83d\udee0 Installation"},{"location":"#hot-reload","text":"Changes to upstreams.yaml are applied immediately. No need to restart the proxy \u2014 just save the file. If consul provider is chosen, upstreams will be periodically update from Consul's API.","title":"\ud83d\udd04 Hot Reload"},{"location":"#tls-support","text":"To enable TLS for A proxy server: Currently only OpenSSL is supported, working on Boringssl and Rustls Set proxy_address_tls in main.yaml Provide tls_certificate and tls_key_file","title":"\ud83d\udd10 TLS Support"},{"location":"#remote-config-api","text":"Push new upstreams.yaml over HTTP to config_address ( :3000 by default). Useful for CI/CD automation or remote config updates. URL parameter. key=MASTERKEY is required. MASTERKEY is the value of master_key in the main.yaml curl -XPOST --data-binary @./etc/upstreams.txt 127 .0.0.1:3000/conf?key = ${ MASTERKEY }","title":"\ud83d\udce1 Remote Config API"},{"location":"#license","text":"Apache License Version 2.0","title":"\ud83d\udcc3 License"},{"location":"#notes","text":"Uses Pingora under the hood for efficiency and flexibility. Designed for edge proxying, internal routing, or hybrid cloud scenarios. Transparent, fully automatic WebSocket upgrade support. Transparent, fully automatic gRPC proxy. Sticky session support. HTTP2 ready. \ud83d\udcca Why Choose Aralez? \u2013 Feature Comparison Feature Aralez Nginx HAProxy Traefik Hot Reload \u2705 Yes (live, API/file) \u26a0\ufe0f Reloads config \u26a0\ufe0f Reloads config \u2705 Yes (dynamic) JWT Auth \u2705 Built-in \u274c External scripts \u274c External Lua or agent \u26a0\ufe0f With plugins WebSocket Support \u2705 Automatic \u26a0\ufe0f Manual config \u2705 Yes \u2705 Yes gRPC Support \u2705 Automatic (no config) \u26a0\ufe0f Manual + HTTP/2 + TLS \u26a0\ufe0f Complex setup \u2705 Native TLS Termination \u2705 Built-in (OpenSSL) \u2705 Yes \u2705 Yes \u2705 Yes TLS Upstream Detection \u2705 Automatic \u274c \u274c \u274c HTTP/2 Support \u2705 Automatic \u26a0\ufe0f Requires extra config \u26a0\ufe0f Requires build flags \u2705 Native Sticky Sessions \u2705 Cookie-based \u26a0\ufe0f In plus version only \u2705 \u2705 Prometheus Metrics \u2705 Built in \u26a0\ufe0f With Lua or exporter \u26a0\ufe0f With external script \u2705 Native Built With \ud83e\udd80 Rust C C Go","title":"\ud83e\udde0 Notes"},{"location":"assets/auth/","text":"\ud83d\udd10 Authentication (Optional) Adds authentication to all requests. Only one method can be active at a time. basic : Standard HTTP Basic Authentication requests. apikey : Authentication via x-api-key header, which should match the value in config. jwt : JWT authentication implemented via araleztoken= url parameter. /some/url?araleztoken=TOKEN jwt : JWT authentication implemented via Authorization: Bearer <token> header. To obtain JWT a token, you should send generate request to built in api server's /jwt endpoint. master_key : should match configured masterkey in main.yaml and upstreams.yaml . owner : Just a placeholder, can be anything. valid : Time in minutes during which the generated token will be valid. Example JWT token generation request PAYLOAD = '{ \"master_key\": \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\", \"owner\": \"valod\", \"valid\": 10 }' TOK = ` curl -s -XPOST -H \"Content-Type: application/json\" -d \" $PAYLOAD \" http://127.0.0.1:3000/jwt | cut -d '\"' -f4 ` echo $TOK Example Request with JWT token With Authorization: Bearer header curl -H \"Authorization: Bearer ${ TOK } \" -H 'Host: myip.mydomain.com' http://127.0.0.1:6193/ With URL parameter (Very useful if you want to generate and share temporary links) curl -H 'Host: myip.mydomain.com' \"http://127.0.0.1:6193/?araleztoken= ${ TOK } `\" Example Request with API Key curl -H \"x-api-key: ${ APIKEY } \" --header 'Host: myip.mydomain.com' http://127.0.0.1:6193/ Example Request with Basic Auth curl -u username:password -H 'Host: myip.mydomain.com' http://127.0.0.1:6193/","title":"Authentication"},{"location":"assets/auth/#authentication-optional","text":"Adds authentication to all requests. Only one method can be active at a time. basic : Standard HTTP Basic Authentication requests. apikey : Authentication via x-api-key header, which should match the value in config. jwt : JWT authentication implemented via araleztoken= url parameter. /some/url?araleztoken=TOKEN jwt : JWT authentication implemented via Authorization: Bearer <token> header. To obtain JWT a token, you should send generate request to built in api server's /jwt endpoint. master_key : should match configured masterkey in main.yaml and upstreams.yaml . owner : Just a placeholder, can be anything. valid : Time in minutes during which the generated token will be valid. Example JWT token generation request PAYLOAD = '{ \"master_key\": \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\", \"owner\": \"valod\", \"valid\": 10 }' TOK = ` curl -s -XPOST -H \"Content-Type: application/json\" -d \" $PAYLOAD \" http://127.0.0.1:3000/jwt | cut -d '\"' -f4 ` echo $TOK Example Request with JWT token With Authorization: Bearer header curl -H \"Authorization: Bearer ${ TOK } \" -H 'Host: myip.mydomain.com' http://127.0.0.1:6193/ With URL parameter (Very useful if you want to generate and share temporary links) curl -H 'Host: myip.mydomain.com' \"http://127.0.0.1:6193/?araleztoken= ${ TOK } `\" Example Request with API Key curl -H \"x-api-key: ${ APIKEY } \" --header 'Host: myip.mydomain.com' http://127.0.0.1:6193/ Example Request with Basic Auth curl -u username:password -H 'Host: myip.mydomain.com' http://127.0.0.1:6193/","title":"\ud83d\udd10 Authentication (Optional)"},{"location":"assets/autossl/","text":"\ud83d\udd10 Obtain and Renew SSL/TLS Certificates with Lego Securing your applications with HTTPS is not just a best practice \u2013 it\u2019s essential ! \ud83d\ude80 With Lego , an ACME client and companion of Let\u2019s Encrypt, you can easily obtain and auto-renew SSL/TLS certificates for your domains. This guide will walk you through preparing Aralez for ACME challenges and integrating certificates smoothly. \ud83c\udf0d\ud83d\udd11 \u2699\ufe0f Step 1: Prepare Aralez for ACME Challenge In order to respond to certificate validation requests, you need to expose the path /.well-known/acme-challenge in your upstream configuration. This allows Let\u2019s Encrypt (or another ACME CA) to verify that you own the domain. Edit main.yaml and set correct folder to proxy_certificates proxy_certificates: /path/to/certificates/for/aralez/ Basic settings in main.yaml requires restart of Aralez. Edit upstreams.yaml . Here\u2019s a sample configuration: myhost.mydomain.com : paths : \"/\" : headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" servers : - \"127.0.0.1:8000\" - \"127.0.0.2:8000\" \"/.well-known/acme-challenge\" : healthcheck : false servers : - \"127.0.0.1:8899\" \u2728 Important Notes: healthcheck: false ensures Aralez does not remove the ephemeral upstreams (temporary validation servers) from the proxy pool. Once saved, Aralez watch and auto-reload upstreams.yaml \ud83d\udd04 \u2013 no manual restart needed! \ud83d\udce5 Step 2: Download and Install Lego Getting Lego installed is a breeze! \ud83e\ude84 Visit the official releases page . Download the precompiled binary for your OS. Extract it (untar if necessary). Make the binary executable: chmod +x lego Move it into your $PATH (e.g., /usr/local/bin): sudo mv lego /usr/local/bin/ \ud83d\udcdc Step 3: Request Certificates Use Lego to request SSL certificates for one or more domain cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site3.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --http.port = 127 .0.0.1:8899 --http run \ud83d\udd0e What happens here? --key-type \u2192 sets the type of cryptographic key (RSA 2048 in this case). --domains \u2192 add one or multiple domains you want to secure. --email \u2192 your contact email (used by Let\u2019s Encrypt). --http.port \u2192 the local port Lego will bind for the HTTP challenge. --accept-tos \u2192 Accept Let's Encrypt terms of service. (default: false). Certificates will be created in the ./.lego/certificates/ directory. \ud83d\uddc2\ufe0f \ud83d\udd17 Step 4: Make Certificates Usable for Aralez Combine and copy the certificates into a path where Aralez expects them: cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key \ud83d\udca1 Pro tip: Instead of manual steps, you can automate with Lego\u2019s built-in hook system using --run-hook. More details: Lego CLI Docs \ud83d\udcda \ud83c\udf89 Step 5: Automatic Reload with Aralez The magic part \u2728 \u2013 Aralez automatically detects changes to your certificates and reloads them on the fly. No downtime. No hassle . Just pure HTTPS goodness. \ud83d\udd12\ud83d\ude80 \ud83d\udca1 Important tip: Aralez expects certificates and keys to follow a specific naming convention: Certificate files must have the .crt extension. Private key files must have the .key extension. Matching .crt and .key files must share the same filename prefix. \ud83d\udcc2 Example: example.com.crt example.com.key \ud83d\udd0e The exact prefix doesn\u2019t matter (it can be any string), but it must be unique per certificate. Aralez scans the certificate and key files, then matches them in memory by content. This ensures the correct pairs are always loaded together. \ud83d\udcdc Step 5: Renewing certificates The easiest is to create a tiny wrapper bash script and put it in crontab. #!/bin/bash cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site3.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --http.port = 127 .0.0.1:8899 --http $1 cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key Crontab entry 0 9 * * * /path/to/lego.sh renew \u2699\ufe0f Using ZeroSSL instead of Let's Encrypt Create an account at ZeroSSL. Login to web app, go to Developer Generate and save your KID and HMAC Create a wrapper script: lego.sh #!/bin/bash cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site1.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --server \"https://acme.zerossl.com/v2/DV90\" \\ --eab --kid \" $YOUR_KID \" \\ --hmac \" $YOUR_HMAC \" \\ --http.port = 127 .0.0.1:8899 --http $1 cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key \ud83d\udd0e What is changed here? --servers \u2192 The URL to ZeroSSL Server. --eab \u2192 EAB copied from developer section of ZeroSSL web app. --hmac \u2192 HMAC copied from developer section of ZeroSSL web app. Obtain the certificate ./lego.sh run Renew the certificate ./lego.sh renew","title":"Manage Certificates"},{"location":"assets/autossl/#obtain-and-renew-ssltls-certificates-with-lego","text":"Securing your applications with HTTPS is not just a best practice \u2013 it\u2019s essential ! \ud83d\ude80 With Lego , an ACME client and companion of Let\u2019s Encrypt, you can easily obtain and auto-renew SSL/TLS certificates for your domains. This guide will walk you through preparing Aralez for ACME challenges and integrating certificates smoothly. \ud83c\udf0d\ud83d\udd11","title":"\ud83d\udd10 Obtain and Renew SSL/TLS Certificates with Lego"},{"location":"assets/autossl/#step-1-prepare-aralez-for-acme-challenge","text":"In order to respond to certificate validation requests, you need to expose the path /.well-known/acme-challenge in your upstream configuration. This allows Let\u2019s Encrypt (or another ACME CA) to verify that you own the domain. Edit main.yaml and set correct folder to proxy_certificates proxy_certificates: /path/to/certificates/for/aralez/ Basic settings in main.yaml requires restart of Aralez. Edit upstreams.yaml . Here\u2019s a sample configuration: myhost.mydomain.com : paths : \"/\" : headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" servers : - \"127.0.0.1:8000\" - \"127.0.0.2:8000\" \"/.well-known/acme-challenge\" : healthcheck : false servers : - \"127.0.0.1:8899\" \u2728 Important Notes: healthcheck: false ensures Aralez does not remove the ephemeral upstreams (temporary validation servers) from the proxy pool. Once saved, Aralez watch and auto-reload upstreams.yaml \ud83d\udd04 \u2013 no manual restart needed!","title":"\u2699\ufe0f Step 1: Prepare Aralez for ACME Challenge"},{"location":"assets/autossl/#step-2-download-and-install-lego","text":"Getting Lego installed is a breeze! \ud83e\ude84 Visit the official releases page . Download the precompiled binary for your OS. Extract it (untar if necessary). Make the binary executable: chmod +x lego Move it into your $PATH (e.g., /usr/local/bin): sudo mv lego /usr/local/bin/","title":"\ud83d\udce5 Step 2: Download and Install Lego"},{"location":"assets/autossl/#step-3-request-certificates","text":"Use Lego to request SSL certificates for one or more domain cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site3.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --http.port = 127 .0.0.1:8899 --http run","title":"\ud83d\udcdc Step 3: Request Certificates"},{"location":"assets/autossl/#what-happens-here","text":"--key-type \u2192 sets the type of cryptographic key (RSA 2048 in this case). --domains \u2192 add one or multiple domains you want to secure. --email \u2192 your contact email (used by Let\u2019s Encrypt). --http.port \u2192 the local port Lego will bind for the HTTP challenge. --accept-tos \u2192 Accept Let's Encrypt terms of service. (default: false). Certificates will be created in the ./.lego/certificates/ directory. \ud83d\uddc2\ufe0f","title":"\ud83d\udd0e What happens here?"},{"location":"assets/autossl/#step-4-make-certificates-usable-for-aralez","text":"Combine and copy the certificates into a path where Aralez expects them: cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key \ud83d\udca1 Pro tip: Instead of manual steps, you can automate with Lego\u2019s built-in hook system using --run-hook. More details: Lego CLI Docs \ud83d\udcda","title":"\ud83d\udd17 Step 4: Make Certificates Usable for Aralez"},{"location":"assets/autossl/#step-5-automatic-reload-with-aralez","text":"The magic part \u2728 \u2013 Aralez automatically detects changes to your certificates and reloads them on the fly. No downtime. No hassle . Just pure HTTPS goodness. \ud83d\udd12\ud83d\ude80 \ud83d\udca1 Important tip: Aralez expects certificates and keys to follow a specific naming convention: Certificate files must have the .crt extension. Private key files must have the .key extension. Matching .crt and .key files must share the same filename prefix. \ud83d\udcc2 Example: example.com.crt example.com.key \ud83d\udd0e The exact prefix doesn\u2019t matter (it can be any string), but it must be unique per certificate. Aralez scans the certificate and key files, then matches them in memory by content. This ensures the correct pairs are always loaded together.","title":"\ud83c\udf89 Step 5: Automatic Reload with Aralez"},{"location":"assets/autossl/#step-5-renewing-certificates","text":"The easiest is to create a tiny wrapper bash script and put it in crontab. #!/bin/bash cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site3.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --http.port = 127 .0.0.1:8899 --http $1 cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key Crontab entry 0 9 * * * /path/to/lego.sh renew","title":"\ud83d\udcdc Step 5: Renewing certificates"},{"location":"assets/autossl/#using-zerossl-instead-of-lets-encrypt","text":"Create an account at ZeroSSL. Login to web app, go to Developer Generate and save your KID and HMAC Create a wrapper script: lego.sh #!/bin/bash cd /path/to/lego/root/folder lego --key-type rsa2048 \\ --domains = \"site1.example.com\" \\ --domains = \"site2.example.com\" \\ --domains = \"site1.example.com\" \\ --email \"your-email@example.com\" \\ --accept-tos \\ --server \"https://acme.zerossl.com/v2/DV90\" \\ --eab --kid \" $YOUR_KID \" \\ --hmac \" $YOUR_HMAC \" \\ --http.port = 127 .0.0.1:8899 --http $1 cat ./.lego/certificates/site1.example.com*.crt > /path/to/certificates/for/aralez/example.com.crt cat ./.lego/certificates/site1.example.com.key > /path/to/certificates/for/aralez/example.com.key","title":"\u2699\ufe0f Using ZeroSSL instead of Let's Encrypt"},{"location":"assets/autossl/#what-is-changed-here","text":"--servers \u2192 The URL to ZeroSSL Server. --eab \u2192 EAB copied from developer section of ZeroSSL web app. --hmac \u2192 HMAC copied from developer section of ZeroSSL web app. Obtain the certificate ./lego.sh run Renew the certificate ./lego.sh renew","title":"\ud83d\udd0e What is changed here?"},{"location":"assets/config/","text":"\ud83d\udee0 Configuration Overview \ud83d\udd27 main.yaml Key Example Value Description threads 12 Number of running daemon threads. Optional, defaults to 1 runuser aralez Optional, Username for running aralez after dropping root privileges, requires to launch as root rungroup aralez Optional,Group for running aralez after dropping root privileges, requires to launch as root daemon false Run in background (boolean) upstream_keepalive_pool_size 500 Pool size for upstream keepalive connections pid_file /tmp/aralez.pid Path to PID file error_log /tmp/aralez_err.log Path to error log file upgrade_sock /tmp/aralez.sock Path to live upgrade socket file config_address 0.0.0.0:3000 HTTP API address for pushing upstreams.yaml from remote location config_tls_address 0.0.0.0:3001 HTTPS API address for pushing upstreams.yaml from remote location config_tls_certificate etc/server.crt Certificate file path for API. Mandatory if proxy_address_tls is set, else optional proxy_tls_grade (high, medium, unsafe) Grade of TLS ciphers, for easy configuration. High matches Qualys SSL Labs A+ (defaults to medium) config_tls_key_file etc/key.pem Private Key file path. Mandatory if proxy_address_tls is set, else optional proxy_address_http 0.0.0.0:6193 Aralez HTTP bind address proxy_address_tls 0.0.0.0:6194 Aralez HTTPS bind address (Optional) proxy_certificates etc/certs/ The directory containing certificate and key files. In a format {NAME}.crt, {NAME}.key. upstreams_conf etc/upstreams.yaml The location of upstreams file log_level info Log level , possible values : info, warn, error, debug, trace, off hc_method HEAD Healthcheck method (HEAD, GET, POST are supported) UPPERCASE hc_interval 2 Interval for health checks in seconds master_key 5aeff7f9-7b94-447c-af60-e8c488544a3e Master key for working with API server and JWT Secret generation file_server_folder /some/local/folder Optional, local folder to serve file_server_address 127.0.0.1:3002 Optional, Local address for file server. Can set as upstream for public access config_api_enabled true Boolean to enable/disable remote config push capability \ud83c\udf10 upstreams.yaml provider : file or consul File-based upstreams define: Hostnames and routing paths Backend servers (load-balanced) Optional request headers, specific to this upstream Global headers (e.g., CORS) apply to all proxied responses Optional authentication (Basic, API Key, JWT) \ud83d\udca1 Example A sample upstreams.yaml entry: provider : \"file\" sticky_sessions : false to_https : false rate_limit : 10 headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" authorization : type : \"jwt\" creds : \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\" myhost.mydomain.com : paths : \"/\" : rate_limit : 20 to_https : false headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Hopaaaaaaaaaaaar\" servers : - \"127.0.0.1:8000\" - \"127.0.0.2:8000\" \"/foo\" : to_https : true headers : - \"X-Another-Header:Hohohohoho\" servers : - \"127.0.0.4:8443\" - \"127.0.0.5:8443\" \"/.well-known/acme-challenge\" : healthcheck : false servers : - \"127.0.0.1:8001\" This means: Sticky sessions are disabled globally. This setting applies to all upstreams. If enabled all requests will be 301 redirected to HTTPS. HTTP to HTTPS redirect disabled globally, but can be overridden by to_https setting per upstream. Requests to each hosted domains will be limited to 10 requests per second per virtualhost. Requests limits are calculated per requester ip plus requested virtualhost. If the requester exceeds the limit it will receive 429 Too Many Requests error. Optional. Rate limiter will be disabled if the parameter is entirely removed from config. Requests to myhost.mydomain.com/ will be limited to 20 requests per second. Requests to myhost.mydomain.com/ will be proxied to 127.0.0.1 and 127.0.0.2 . Plain HTTP to myhost.mydomain.com/foo will get 301 redirect to configured TLS port of Aralez. Requests to myhost.mydomain.com/foo will be proxied to 127.0.0.4 and 127.0.0.5 . Requests to myhost.mydomain.com/.well-known/acme-challenge will be proxied to 127.0.0.1:8001 , but healthcheks are disabled. SSL/TLS for upstreams is detected automatically, no need to set any config parameter. Assuming the 127.0.0.5:8443 is SSL protected. The inner traffic will use TLS. Self-signed certificates are silently accepted. Global headers (CORS for this case) will be injected to all upstreams. Additional headers will be injected into the request for myhost.mydomain.com . You can choose any path, deep nested paths are supported, the best match chosen. All requests to servers will require JWT token authentication (You can comment out the authorization to disable it), Firs parameter specifies the mechanism of authorisation jwt Second is the secret key for validating jwt tokens","title":"Config"},{"location":"assets/config/#configuration-overview","text":"","title":"\ud83d\udee0 Configuration Overview"},{"location":"assets/config/#mainyaml","text":"Key Example Value Description threads 12 Number of running daemon threads. Optional, defaults to 1 runuser aralez Optional, Username for running aralez after dropping root privileges, requires to launch as root rungroup aralez Optional,Group for running aralez after dropping root privileges, requires to launch as root daemon false Run in background (boolean) upstream_keepalive_pool_size 500 Pool size for upstream keepalive connections pid_file /tmp/aralez.pid Path to PID file error_log /tmp/aralez_err.log Path to error log file upgrade_sock /tmp/aralez.sock Path to live upgrade socket file config_address 0.0.0.0:3000 HTTP API address for pushing upstreams.yaml from remote location config_tls_address 0.0.0.0:3001 HTTPS API address for pushing upstreams.yaml from remote location config_tls_certificate etc/server.crt Certificate file path for API. Mandatory if proxy_address_tls is set, else optional proxy_tls_grade (high, medium, unsafe) Grade of TLS ciphers, for easy configuration. High matches Qualys SSL Labs A+ (defaults to medium) config_tls_key_file etc/key.pem Private Key file path. Mandatory if proxy_address_tls is set, else optional proxy_address_http 0.0.0.0:6193 Aralez HTTP bind address proxy_address_tls 0.0.0.0:6194 Aralez HTTPS bind address (Optional) proxy_certificates etc/certs/ The directory containing certificate and key files. In a format {NAME}.crt, {NAME}.key. upstreams_conf etc/upstreams.yaml The location of upstreams file log_level info Log level , possible values : info, warn, error, debug, trace, off hc_method HEAD Healthcheck method (HEAD, GET, POST are supported) UPPERCASE hc_interval 2 Interval for health checks in seconds master_key 5aeff7f9-7b94-447c-af60-e8c488544a3e Master key for working with API server and JWT Secret generation file_server_folder /some/local/folder Optional, local folder to serve file_server_address 127.0.0.1:3002 Optional, Local address for file server. Can set as upstream for public access config_api_enabled true Boolean to enable/disable remote config push capability","title":"\ud83d\udd27 main.yaml"},{"location":"assets/config/#upstreamsyaml","text":"provider : file or consul File-based upstreams define: Hostnames and routing paths Backend servers (load-balanced) Optional request headers, specific to this upstream Global headers (e.g., CORS) apply to all proxied responses Optional authentication (Basic, API Key, JWT)","title":"\ud83c\udf10 upstreams.yaml"},{"location":"assets/config/#example","text":"A sample upstreams.yaml entry: provider : \"file\" sticky_sessions : false to_https : false rate_limit : 10 headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" authorization : type : \"jwt\" creds : \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\" myhost.mydomain.com : paths : \"/\" : rate_limit : 20 to_https : false headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Hopaaaaaaaaaaaar\" servers : - \"127.0.0.1:8000\" - \"127.0.0.2:8000\" \"/foo\" : to_https : true headers : - \"X-Another-Header:Hohohohoho\" servers : - \"127.0.0.4:8443\" - \"127.0.0.5:8443\" \"/.well-known/acme-challenge\" : healthcheck : false servers : - \"127.0.0.1:8001\" This means: Sticky sessions are disabled globally. This setting applies to all upstreams. If enabled all requests will be 301 redirected to HTTPS. HTTP to HTTPS redirect disabled globally, but can be overridden by to_https setting per upstream. Requests to each hosted domains will be limited to 10 requests per second per virtualhost. Requests limits are calculated per requester ip plus requested virtualhost. If the requester exceeds the limit it will receive 429 Too Many Requests error. Optional. Rate limiter will be disabled if the parameter is entirely removed from config. Requests to myhost.mydomain.com/ will be limited to 20 requests per second. Requests to myhost.mydomain.com/ will be proxied to 127.0.0.1 and 127.0.0.2 . Plain HTTP to myhost.mydomain.com/foo will get 301 redirect to configured TLS port of Aralez. Requests to myhost.mydomain.com/foo will be proxied to 127.0.0.4 and 127.0.0.5 . Requests to myhost.mydomain.com/.well-known/acme-challenge will be proxied to 127.0.0.1:8001 , but healthcheks are disabled. SSL/TLS for upstreams is detected automatically, no need to set any config parameter. Assuming the 127.0.0.5:8443 is SSL protected. The inner traffic will use TLS. Self-signed certificates are silently accepted. Global headers (CORS for this case) will be injected to all upstreams. Additional headers will be injected into the request for myhost.mydomain.com . You can choose any path, deep nested paths are supported, the best match chosen. All requests to servers will require JWT token authentication (You can comment out the authorization to disable it), Firs parameter specifies the mechanism of authorisation jwt Second is the secret key for validating jwt tokens","title":"\ud83d\udca1 Example"},{"location":"assets/kubernetes/","text":"\ud83d\udcc8 Aralez & Kubernetes Integration Guide This guide walks you through setting up Aralez to run smoothly inside a Kubernetes cluster as a lightweight service mesh. We\u2019ll create the necessary ServiceAccount , apply the right RBAC roles , and then deploy Aralez as a Kubernetes Deployment with an exposed Service. \ud83d\udd11 Step 1: Create a Service Account Aralez needs a ServiceAccount with permissions to watch Kubernetes resources like pods, endpoints, and services. You can define it in YAML: apiVersion : v1 kind : ServiceAccount metadata : name : aralez-sa \ud83d\udcdc Step 2: Define RBAC Permissions Aralez requires read-only access to Kubernetes resources within a namespace. Role (scoped to a single namespace): apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : aralez-role rules : - apiGroups : [ \"\" ] resources : [ \"pods\" , \"endpoints\" , \"services\" ] verbs : [ \"get\" , \"list\" , \"watch\" ] RoleBinding (attach Role to the ServiceAccount): apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : aralez-binding subjects : - kind : ServiceAccount name : aralez-sa roleRef : kind : Role name : aralez-role apiGroup : rbac.authorization.k8s.io \ud83d\ude80 Step 3: Deploy Aralez Here\u2019s a minimal deployment example for running Aralez in your cluster. Configs \u2192 ConfigMap. Arbitrary configs like main.yaml, upstreams.yml, etc. Example :main.yml threads : 12 daemon : false upstream_keepalive_pool_size : 500 pid_file : /tmp/aralez.pid error_log : /tmp/aralez_err.log upgrade_sock : /tmp/aralez.sock config_api_enabled : false config_address : 127.0.0.1:3000 proxy_address_http : 0.0.0.0:80 proxy_address_tls : 0.0.0.0:443 proxy_certificates : /etc/aralez/certs proxy_tls_grade : high upstreams_conf : /etc/aralez/config/upstreams.yml log_level : info hc_method : HEAD hc_interval : 2 master_key : 910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774 Example :upstreams.yml provider : \"kubernetes\" sticky_sessions : false to_https : false rate_limit : 100 headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" - \"Strict-Transport-Security:max-age=31536000; includeSubDomains; preload\" #authorization: # type: \"jwt\" # creds: \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\" # type: \"basic\" # creds: \"zangag:Anhnazand1234\" # type: \"apikey\" # creds: \"5ecbf799-1343-4e94-a9b5-e278af5cd313-56b45249-1839-4008-a450-a60dc76d2bae\" kubernetes : services : - hostname : \"vt-webapi-service\" path : \"/\" upstream : \"vt-webapi-service\" - hostname : \"vt-webapi-service\" upstream : \"vt-console-service\" path : \"/one\" headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 100 to_https : false - hostname : \"vt-webapi-service\" upstream : \"vt-rambulik-service\" path : \"/two\" - hostname : \"vt-websocket-service\" upstream : \"vt-websocket-service\" path : \"/\" tokenpath : \"/var/run/secrets/kubernetes.io/serviceaccount/token\" Apply config maps kubectl -n staging create configmap aralez-main-config --from-file = main.yaml = ./main.yaml kubectl -n staging create configmap aralez-upstreams-config --from-file = upstreams.yml = ./upstreams.yaml Create certificate and private key secrets for TLS apiVersion : v1 kind : Secret metadata : name : aralez-tls type : kubernetes.io/tls data : tls.crt : <base64-cert> tls.key : <base64-key> Deployment Aralez Example :deployment.yaml apiVersion : apps/v1 kind : Deployment metadata : name : aralez spec : replicas : 1 selector : matchLabels : app : aralez template : metadata : labels : app : aralez spec : serviceAccountName : aralez-sa containers : - name : aralez image : sadoyan/aralez:latest ports : - containerPort : 80 - containerPort : 443 volumeMounts : - name : main-config mountPath : /etc/aralez/main.yaml subPath : main.yaml readOnly : true - name : upstreams-config mountPath : /etc/aralez/config/upstreams.yml subPath : upstreams.yml readOnly : true - name : tls-certs mountPath : /etc/aralez/certs readOnly : true volumes : - name : main-config configMap : name : aralez-main-config - name : upstreams-config configMap : name : aralez-upstreams-config - name : tls-certs secret : secretName : aralez-tls Create Aralez service Example :service.yaml apiVersion : v1 kind : Service metadata : name : aralez-service spec : type : NodePort selector : app : aralez ports : - name : http port : 80 targetPort : 80 - name : https port : 443 targetPort : 443 \ud83c\udf10 Step 4: Expose Aralez with a Service Depending on how you want to reach Aralez, you can expose it in different ways. ClusterIP (internal access only): apiVersion : v1 kind : Service metadata : name : aralez namespace : default spec : selector : app : aralez ports : - port : 80 targetPort : 80 NodePort or LoadBalancer (external access): spec : type : NodePort # Use LoadBalancer if running in a cloud environment \u2705 That\u2019s it! Aralez is now running inside your Kubernetes cluster with the right permissions and is accessible through a Kubernetes Service.","title":"Kubernetes Ingress"},{"location":"assets/kubernetes/#aralez-kubernetes-integration-guide","text":"This guide walks you through setting up Aralez to run smoothly inside a Kubernetes cluster as a lightweight service mesh. We\u2019ll create the necessary ServiceAccount , apply the right RBAC roles , and then deploy Aralez as a Kubernetes Deployment with an exposed Service.","title":"\ud83d\udcc8 Aralez &amp; Kubernetes Integration Guide"},{"location":"assets/kubernetes/#step-1-create-a-service-account","text":"Aralez needs a ServiceAccount with permissions to watch Kubernetes resources like pods, endpoints, and services. You can define it in YAML: apiVersion : v1 kind : ServiceAccount metadata : name : aralez-sa","title":"\ud83d\udd11 Step 1: Create a Service Account"},{"location":"assets/kubernetes/#step-2-define-rbac-permissions","text":"Aralez requires read-only access to Kubernetes resources within a namespace. Role (scoped to a single namespace): apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : aralez-role rules : - apiGroups : [ \"\" ] resources : [ \"pods\" , \"endpoints\" , \"services\" ] verbs : [ \"get\" , \"list\" , \"watch\" ] RoleBinding (attach Role to the ServiceAccount): apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : aralez-binding subjects : - kind : ServiceAccount name : aralez-sa roleRef : kind : Role name : aralez-role apiGroup : rbac.authorization.k8s.io","title":"\ud83d\udcdc Step 2: Define RBAC Permissions"},{"location":"assets/kubernetes/#step-3-deploy-aralez","text":"Here\u2019s a minimal deployment example for running Aralez in your cluster.","title":"\ud83d\ude80 Step 3: Deploy Aralez"},{"location":"assets/kubernetes/#configs-configmap-arbitrary-configs-like-mainyaml-upstreamsyml-etc","text":"Example :main.yml threads : 12 daemon : false upstream_keepalive_pool_size : 500 pid_file : /tmp/aralez.pid error_log : /tmp/aralez_err.log upgrade_sock : /tmp/aralez.sock config_api_enabled : false config_address : 127.0.0.1:3000 proxy_address_http : 0.0.0.0:80 proxy_address_tls : 0.0.0.0:443 proxy_certificates : /etc/aralez/certs proxy_tls_grade : high upstreams_conf : /etc/aralez/config/upstreams.yml log_level : info hc_method : HEAD hc_interval : 2 master_key : 910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774 Example :upstreams.yml provider : \"kubernetes\" sticky_sessions : false to_https : false rate_limit : 100 headers : - \"Access-Control-Allow-Origin:*\" - \"Access-Control-Allow-Methods:POST, GET, OPTIONS\" - \"Access-Control-Max-Age:86400\" - \"Strict-Transport-Security:max-age=31536000; includeSubDomains; preload\" #authorization: # type: \"jwt\" # creds: \"910517d9-f9a1-48de-8826-dbadacbd84af-cb6f830e-ab16-47ec-9d8f-0090de732774\" # type: \"basic\" # creds: \"zangag:Anhnazand1234\" # type: \"apikey\" # creds: \"5ecbf799-1343-4e94-a9b5-e278af5cd313-56b45249-1839-4008-a450-a60dc76d2bae\" kubernetes : services : - hostname : \"vt-webapi-service\" path : \"/\" upstream : \"vt-webapi-service\" - hostname : \"vt-webapi-service\" upstream : \"vt-console-service\" path : \"/one\" headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" rate_limit : 100 to_https : false - hostname : \"vt-webapi-service\" upstream : \"vt-rambulik-service\" path : \"/two\" - hostname : \"vt-websocket-service\" upstream : \"vt-websocket-service\" path : \"/\" tokenpath : \"/var/run/secrets/kubernetes.io/serviceaccount/token\" Apply config maps kubectl -n staging create configmap aralez-main-config --from-file = main.yaml = ./main.yaml kubectl -n staging create configmap aralez-upstreams-config --from-file = upstreams.yml = ./upstreams.yaml","title":"Configs \u2192 ConfigMap. Arbitrary configs like main.yaml, upstreams.yml, etc."},{"location":"assets/kubernetes/#create-certificate-and-private-key-secrets-for-tls","text":"apiVersion : v1 kind : Secret metadata : name : aralez-tls type : kubernetes.io/tls data : tls.crt : <base64-cert> tls.key : <base64-key>","title":"Create certificate and private key secrets for TLS"},{"location":"assets/kubernetes/#deployment-aralez","text":"Example :deployment.yaml apiVersion : apps/v1 kind : Deployment metadata : name : aralez spec : replicas : 1 selector : matchLabels : app : aralez template : metadata : labels : app : aralez spec : serviceAccountName : aralez-sa containers : - name : aralez image : sadoyan/aralez:latest ports : - containerPort : 80 - containerPort : 443 volumeMounts : - name : main-config mountPath : /etc/aralez/main.yaml subPath : main.yaml readOnly : true - name : upstreams-config mountPath : /etc/aralez/config/upstreams.yml subPath : upstreams.yml readOnly : true - name : tls-certs mountPath : /etc/aralez/certs readOnly : true volumes : - name : main-config configMap : name : aralez-main-config - name : upstreams-config configMap : name : aralez-upstreams-config - name : tls-certs secret : secretName : aralez-tls","title":"Deployment Aralez"},{"location":"assets/kubernetes/#create-aralez-service","text":"Example :service.yaml apiVersion : v1 kind : Service metadata : name : aralez-service spec : type : NodePort selector : app : aralez ports : - name : http port : 80 targetPort : 80 - name : https port : 443 targetPort : 443","title":"Create Aralez service"},{"location":"assets/kubernetes/#step-4-expose-aralez-with-a-service","text":"Depending on how you want to reach Aralez, you can expose it in different ways. ClusterIP (internal access only): apiVersion : v1 kind : Service metadata : name : aralez namespace : default spec : selector : app : aralez ports : - port : 80 targetPort : 80 NodePort or LoadBalancer (external access): spec : type : NodePort # Use LoadBalancer if running in a cloud environment \u2705 That\u2019s it! Aralez is now running inside your Kubernetes cluster with the right permissions and is accessible through a Kubernetes Service.","title":"\ud83c\udf10 Step 4: Expose Aralez with a Service"},{"location":"assets/metrics/","text":"\ud83d\udcc8 Aralez Prometheus Metrics Reference This document outlines Prometheus metrics for the Aralez reverse proxy. These metrics can be used for monitoring, alerting and performance analysis. Exposed to http://config_address/metrics By default http://127.0.0.1:3000/metrics \ud83d\udcca Example Grafana dashboard during stress test : \ud83d\udee0\ufe0f Prometheus Metrics 1. aralez_requests_total Type : Counter Purpose : Total amount requests served by Aralez. PromQL example: rate ( aralez_requests_total [ 5m ] ) 2. aralez_errors_total Type : Counter Purpose : Count of requests that resulted in an error. PromQL example: rate ( aralez_errors_total [ 5m ] ) 3. aralez_responses_total{status=\"200\"} Type : CounterVec Purpose : Count of responses by HTTP status code. PromQL example: rate ( aralez_responses_total { status =~ \" 5.. \"}[ 5m ] ) > 0 Useful for alerting on 5xx errors. 4. aralez_response_latency_seconds Type : Histogram Purpose : Tracks the latency of responses in seconds. Example bucket output: aralez_response_latency_seconds_bucket{le=\"0.01\"} 15 aralez_response_latency_seconds_bucket{le=\"0.1\"} 120 aralez_response_latency_seconds_bucket{le=\"0.25\"} 245 aralez_response_latency_seconds_bucket{le=\"0.5\"} 500 ... aralez_response_latency_seconds_count 1023 aralez_response_latency_seconds_sum 42.6 Metric Meaning bucket{le=\"0.1\"} 120 120 requests were \u2264 100ms bucket{le=\"0.25\"} 245 245 requests were \u2264 250ms count Total number of observations (i.e., total responses measured) sum Total time of all responses, in seconds \ud83d\udd0d How to interpret: le means \u201cless than or equal to\u201d. count is total amount of observations. sum is the total time (in seconds) of all responses. PromQL examples: \ud83d\udd39 95th percentile latency histogram_quantile ( 0.95 , rate ( aralez_response_latency_seconds_bucket [ 5m ] )) \ud83d\udd39 Average latency rate ( aralez_response_latency_seconds_sum [ 5m ] ) / rate ( aralez_response_latency_seconds_count [ 5m ] ) \u2705 Notes Metrics are registered after the first served request. \u2705 Summary of key metrics Metric Name Type What it Tells You aralez_requests_total Counter Total requests served aralez_errors_total Counter Number of failed requests aralez_responses_total{status=\"200\"} CounterVec Response status breakdown aralez_response_latency_seconds Histogram How fast responses are","title":"Prometheus Metrics"},{"location":"assets/metrics/#aralez-prometheus-metrics-reference","text":"This document outlines Prometheus metrics for the Aralez reverse proxy. These metrics can be used for monitoring, alerting and performance analysis. Exposed to http://config_address/metrics By default http://127.0.0.1:3000/metrics","title":"\ud83d\udcc8 Aralez Prometheus Metrics Reference"},{"location":"assets/metrics/#example-grafana-dashboard-during-stress-test","text":"","title":"\ud83d\udcca Example Grafana dashboard during stress test :"},{"location":"assets/metrics/#prometheus-metrics","text":"","title":"\ud83d\udee0\ufe0f Prometheus Metrics"},{"location":"assets/metrics/#1-aralez_requests_total","text":"Type : Counter Purpose : Total amount requests served by Aralez. PromQL example: rate ( aralez_requests_total [ 5m ] )","title":"1. aralez_requests_total"},{"location":"assets/metrics/#2-aralez_errors_total","text":"Type : Counter Purpose : Count of requests that resulted in an error. PromQL example: rate ( aralez_errors_total [ 5m ] )","title":"2. aralez_errors_total"},{"location":"assets/metrics/#3-aralez_responses_totalstatus200","text":"Type : CounterVec Purpose : Count of responses by HTTP status code. PromQL example: rate ( aralez_responses_total { status =~ \" 5.. \"}[ 5m ] ) > 0 Useful for alerting on 5xx errors.","title":"3. aralez_responses_total{status=\"200\"}"},{"location":"assets/metrics/#4-aralez_response_latency_seconds","text":"Type : Histogram Purpose : Tracks the latency of responses in seconds. Example bucket output: aralez_response_latency_seconds_bucket{le=\"0.01\"} 15 aralez_response_latency_seconds_bucket{le=\"0.1\"} 120 aralez_response_latency_seconds_bucket{le=\"0.25\"} 245 aralez_response_latency_seconds_bucket{le=\"0.5\"} 500 ... aralez_response_latency_seconds_count 1023 aralez_response_latency_seconds_sum 42.6 Metric Meaning bucket{le=\"0.1\"} 120 120 requests were \u2264 100ms bucket{le=\"0.25\"} 245 245 requests were \u2264 250ms count Total number of observations (i.e., total responses measured) sum Total time of all responses, in seconds","title":"4. aralez_response_latency_seconds"},{"location":"assets/metrics/#how-to-interpret","text":"le means \u201cless than or equal to\u201d. count is total amount of observations. sum is the total time (in seconds) of all responses. PromQL examples: \ud83d\udd39 95th percentile latency histogram_quantile ( 0.95 , rate ( aralez_response_latency_seconds_bucket [ 5m ] )) \ud83d\udd39 Average latency rate ( aralez_response_latency_seconds_sum [ 5m ] ) / rate ( aralez_response_latency_seconds_count [ 5m ] )","title":"\ud83d\udd0d How to interpret:"},{"location":"assets/metrics/#notes","text":"Metrics are registered after the first served request. \u2705 Summary of key metrics Metric Name Type What it Tells You aralez_requests_total Counter Total requests served aralez_errors_total Counter Number of failed requests aralez_responses_total{status=\"200\"} CounterVec Response status breakdown aralez_response_latency_seconds Histogram How fast responses are","title":"\u2705 Notes"},{"location":"assets/perf/","text":"\ud83d\ude80 Aralez performance benchmarks \ud83d\udca1 Simple benchmark by Oha \u26a0\ufe0f These benchmarks use : 3 async Rust echo servers on a local network with 1Gbit as upstreams. A dedicated server for running Aralez A dedicated server for running Oha The following upstreams configuration. 9 test URLs from simple / to nested up to 7 subpaths. myhost.mydomain.com : paths : \"/\" : to_https : false headers : - \"X-Proxy-From:Aralez\" servers : - \"192.168.211.211:8000\" - \"192.168.211.212:8000\" - \"192.168.211.213:8000\" \"/ping\" : to_https : false headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" servers : - \"192.168.211.211:8000\" - \"192.168.211.212:8000\" \ud83d\udca1 Results reflect synthetic performance under optimal conditions. CPU : Intel(R) Xeon(R) CPU E3-1270 v6 @ 3.80GHz 300 : simultaneous connections Duration : 10 Minutes Binary : aralez-x86_64-glibc Summary : Success rate : 100.00 % Total : 600.0027 secs Slowest : 0.2138 secs Fastest : 0.0002 secs Average : 0.0023 secs Requests / sec : 129777.3838 Total data : 0 B Size / request : 0 B Size / sec : 0 B Response time histogram : 0.000 [ 1 ] | 0.022 [ 77668026 ] | \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 0.043 [ 190362 ] | 0.064 [ 7908 ] | 0.086 [ 319 ] | 0.107 [ 4 ] | 0.128 [ 0 ] | 0.150 [ 0 ] | 0.171 [ 0 ] | 0.192 [ 0 ] | 0.214 [ 4 ] | Response time distribution : 10.00 % in 0.0012 secs 25.00 % in 0.0016 secs 50.00 % in 0.0020 secs 75.00 % in 0.0026 secs 90.00 % in 0.0033 secs 95.00 % in 0.0040 secs 99.00 % in 0.0078 secs 99.90 % in 0.0278 secs 99.99 % in 0.0434 secs Details ( average , fastest , slowest ): DNS + dialup : 0.0161 secs , 0.0002 secs , 0.0316 secs DNS - lookup : 0.0000 secs , 0.0000 secs , 0.0000 secs Status code distribution : [ 200 ] 77866624 responses Error distribution : [ 158 ] aborted due to deadline CPU : Intel(R) Xeon(R) CPU E3-1270 v6 @ 3.80GHz 300 : simultaneous connections Duration : 10 Minutes Binary : aralez-x86_64-musl Summary : Success rate : 100.00 % Total : 600.0021 secs Slowest : 0.2182 secs Fastest : 0.0002 secs Average : 0.0024 secs Requests / sec : 123870.5820 Total data : 0 B Size / request : 0 B Size / sec : 0 B Response time histogram : 0.000 [ 1 ] | 0.022 [ 74254679 ] | \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 0.044 [ 61400 ] | 0.066 [ 5911 ] | 0.087 [ 385 ] | 0.109 [ 0 ] | 0.131 [ 0 ] | 0.153 [ 0 ] | 0.175 [ 0 ] | 0.196 [ 0 ] | 0.218 [ 1 ] | Response time distribution : 10.00 % in 0.0012 secs 25.00 % in 0.0016 secs 50.00 % in 0.0021 secs 75.00 % in 0.0028 secs 90.00 % in 0.0037 secs 95.00 % in 0.0045 secs 99.00 % in 0.0077 secs 99.90 % in 0.0214 secs 99.99 % in 0.0424 secs Details ( average , fastest , slowest ): DNS + dialup : 0.0066 secs , 0.0002 secs , 0.0210 secs DNS - lookup : 0.0000 secs , 0.0000 secs , 0.0000 secs Status code distribution : [ 200 ] 74322377 responses Error distribution : [ 228 ] aborted due to deadline \ud83d\ude80 Aralez, Nginx, Traefik performance benchmark This benchmark is done on 4 servers. With CPU Intel(R) Xeon(R) E-2174G CPU @ 3.80GHz, 64 GB RAM. Sever runs Aralez, Traefik, Nginx on different ports. Tuned as much as I could . 3x Upstreams servers, running Nginx. Replying with dummy json hardcoded in config file for max performance. All servers are connected to the same switch with 1GB port in datacenter , not a home lab. The results: The results show requests per second performed by Load balancer. You can see 3 batches with 800 concurrent users. Requests via http1.1 to plain text endpoint. Requests to via http2 to SSL endpoint. Mixed workload with plain http1.1 and htt2 SSL.","title":"Benchmarks"},{"location":"assets/perf/#aralez-performance-benchmarks","text":"","title":"\ud83d\ude80 Aralez performance benchmarks"},{"location":"assets/perf/#simple-benchmark-by-oha","text":"\u26a0\ufe0f These benchmarks use : 3 async Rust echo servers on a local network with 1Gbit as upstreams. A dedicated server for running Aralez A dedicated server for running Oha The following upstreams configuration. 9 test URLs from simple / to nested up to 7 subpaths. myhost.mydomain.com : paths : \"/\" : to_https : false headers : - \"X-Proxy-From:Aralez\" servers : - \"192.168.211.211:8000\" - \"192.168.211.212:8000\" - \"192.168.211.213:8000\" \"/ping\" : to_https : false headers : - \"X-Some-Thing:Yaaaaaaaaaaaaaaa\" - \"X-Proxy-From:Aralez\" servers : - \"192.168.211.211:8000\" - \"192.168.211.212:8000\" \ud83d\udca1 Results reflect synthetic performance under optimal conditions. CPU : Intel(R) Xeon(R) CPU E3-1270 v6 @ 3.80GHz 300 : simultaneous connections Duration : 10 Minutes Binary : aralez-x86_64-glibc Summary : Success rate : 100.00 % Total : 600.0027 secs Slowest : 0.2138 secs Fastest : 0.0002 secs Average : 0.0023 secs Requests / sec : 129777.3838 Total data : 0 B Size / request : 0 B Size / sec : 0 B Response time histogram : 0.000 [ 1 ] | 0.022 [ 77668026 ] | \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 0.043 [ 190362 ] | 0.064 [ 7908 ] | 0.086 [ 319 ] | 0.107 [ 4 ] | 0.128 [ 0 ] | 0.150 [ 0 ] | 0.171 [ 0 ] | 0.192 [ 0 ] | 0.214 [ 4 ] | Response time distribution : 10.00 % in 0.0012 secs 25.00 % in 0.0016 secs 50.00 % in 0.0020 secs 75.00 % in 0.0026 secs 90.00 % in 0.0033 secs 95.00 % in 0.0040 secs 99.00 % in 0.0078 secs 99.90 % in 0.0278 secs 99.99 % in 0.0434 secs Details ( average , fastest , slowest ): DNS + dialup : 0.0161 secs , 0.0002 secs , 0.0316 secs DNS - lookup : 0.0000 secs , 0.0000 secs , 0.0000 secs Status code distribution : [ 200 ] 77866624 responses Error distribution : [ 158 ] aborted due to deadline CPU : Intel(R) Xeon(R) CPU E3-1270 v6 @ 3.80GHz 300 : simultaneous connections Duration : 10 Minutes Binary : aralez-x86_64-musl Summary : Success rate : 100.00 % Total : 600.0021 secs Slowest : 0.2182 secs Fastest : 0.0002 secs Average : 0.0024 secs Requests / sec : 123870.5820 Total data : 0 B Size / request : 0 B Size / sec : 0 B Response time histogram : 0.000 [ 1 ] | 0.022 [ 74254679 ] | \u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0\u25a0 0.044 [ 61400 ] | 0.066 [ 5911 ] | 0.087 [ 385 ] | 0.109 [ 0 ] | 0.131 [ 0 ] | 0.153 [ 0 ] | 0.175 [ 0 ] | 0.196 [ 0 ] | 0.218 [ 1 ] | Response time distribution : 10.00 % in 0.0012 secs 25.00 % in 0.0016 secs 50.00 % in 0.0021 secs 75.00 % in 0.0028 secs 90.00 % in 0.0037 secs 95.00 % in 0.0045 secs 99.00 % in 0.0077 secs 99.90 % in 0.0214 secs 99.99 % in 0.0424 secs Details ( average , fastest , slowest ): DNS + dialup : 0.0066 secs , 0.0002 secs , 0.0210 secs DNS - lookup : 0.0000 secs , 0.0000 secs , 0.0000 secs Status code distribution : [ 200 ] 74322377 responses Error distribution : [ 228 ] aborted due to deadline","title":"\ud83d\udca1 Simple benchmark by Oha"},{"location":"assets/perf/#aralez-nginx-traefik-performance-benchmark","text":"This benchmark is done on 4 servers. With CPU Intel(R) Xeon(R) E-2174G CPU @ 3.80GHz, 64 GB RAM. Sever runs Aralez, Traefik, Nginx on different ports. Tuned as much as I could . 3x Upstreams servers, running Nginx. Replying with dummy json hardcoded in config file for max performance. All servers are connected to the same switch with 1GB port in datacenter , not a home lab. The results: The results show requests per second performed by Load balancer. You can see 3 batches with 800 concurrent users. Requests via http1.1 to plain text endpoint. Requests to via http2 to SSL endpoint. Mixed workload with plain http1.1 and htt2 SSL.","title":"\ud83d\ude80 Aralez, Nginx, Traefik performance benchmark"}]}